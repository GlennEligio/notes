Section 34 - Terraform Basics

Contents:
177. Using Terraform Providers
178. Lab: Terraform Providers
179. Configuration Directory
180. Multiple Providers
181. Lab: Multiple Providers
182. Using Input Variables
183. Understanding the Variable Block
184. Lab: Variables
185. Using Variables in Terraform
186. Lab: Using Variables in Terraform
187. Resource Attributes
188. Lab: Resource Attributes
189. Resource Dependencies
190. Lab: Resource Dependencies
191. Output Variables
192. Lab: Output Variables


177. Using Terraform Providers

Using Terraform Providers
 > to use Terraform Providers, we would need to install the plugins for the providers used within the configuration
	- we would need to use 'terraform init' command to install these
	
Providers and Plugins
 > these can plugins for different providers like cloud providers (e.g. AWS, GCP, Azure), or something as simple as the local provider that we use to create a local file type resource
 > Terraform uses a PLUGIN-BASED architecture to work with hundreds of such infrastructure platform
 > Different providers are distributed y Hashicorp, and are publicly available in the TerraForm Registry at the url
	- registry.terraform.io
	
Tiers of Providers
 > there are three tiers of providers	
	1. Offical providers
	2. Verified providers
	3. Community providers
 > Official providers are owned and maintained by Hashicorp, and include the major cloud providers such as AWS, GCP and Azure
	- the Local provider that we used so far is also an official provider
 > Verified provider is owned and maintained by a third party technology company that has gone through a partner provider process with Hashicorp
	- some of the examples are the
		1. bigip - by F5Networks
		2. heroku
		3. digitalocean
 > Community providers that are published and maintained by individual contributors of the Hashicorp community
 
 
Plugins installation
 > when we use 'terraform init' command, we could also see the VERSIONS of the plugins installed
	- we can execute the command above as many times as we want without impacting the infrastructure deployed
 > by DEFAULT, Terraform install the LATEST VERSION
 > the plugins are then downloaded into a hidden directory called './terraform/plugins' in the working directory containing the configuration files
 
EX:
	- main.tf
	> .terraform
		> plugins 
		
EX: logs when performing 'terraform init' command
$ terraform init
Intializing the backend...

Intializing provider plugin...
- Finding latest version of hashicorp/local...
- Installing hashicorp/local v2.0.0...
- Installed hashicorp/local v2.0.0 (signed by Hashicorp)

The following providers do not have any version constraints in the configuration, so the latest version was installed

To prevent automatic upgrades to new major versions that may contain breaking changes, we recommend adding version constraints in a required providers block in your configurations, with the constraint strings suggested below

* hashicorp/local: version = "~> 2.0.0"

Terraform has been successfully initialized!
		
	
	
Plugin identifiers
 > each plugins have their own identifiers which is used to identify them in the Terraform registry
 > the format of the plugin identifier is HOSTNAME/ORGANIZATIONAL_NAMESPACE/TYPE
	- HOSTNAME is optional
		- this is the name of the registry where the plugin is located
		- if not provided, will default to registry.terraform.io
	- ORGANIZATIONAL_NAMESPACE is the organization namespace of the plugin
	- TYPE is the name of the provider
		= examples are local, aws, azure, gcp
 > example is hashicorp/local
	- since hostname is omitted, it will use registry.terraform.io
	- hashicorp is the namespace
	- local is the provider
	
	
Using specific version of plugin
 > we typically do this to lock down our configuration files
 > this is due to some new versions by introducing breaking changes that can affect our configuration





178. Lab: Terraform Providers

#1
Q: We have a new configuration directory located at the path '/root/terraform-project/things-to-do'. Inspect this directory and find out the number of providers initialized within this directory.
Do not run terraform init yet!
S: One file main.tf
resource "local_file" "things-to-do" {
  filename     = "/root/things-to-do.txt"
  content  = "Clean my room before Christmas\nComplete the CKA Certification!"
}
resource "local_file" "more-things-to-do" {
  filename     = "/root/more-things-to-do.txt"
  content  = "Learn how to play Astronomia on the guitar!"
}
A: 0, since the .terraform/providers does not have content


#2
Q: How about now? How many providers plugins are installed in this configuration directory.
A: 1, checking the .terraform hidden directory


#3
Q: How many configuration files exist in the directory: /root/terraform-project/things-to-do?
A: 1, the main.tf

#4
Q: How many resources are configured in this configuration directory?
Count all the resource blocks used.
A: 2, the things-to-do and more-things-to-do resources

#5
Q: What is the version of the plugin for the local provider that has been downloaded for this configuration?
A: 2.4.1, based on what .terraform directory contain, as well as the 'terraform init' output

#6
Q: Now, go ahead and create these resources using terraform!
Once done, the two files defined inside the resource blocks should be created with the correct file names and content.
S: Use 'terraform init', 'terraform plan', and 'terraform apply'. This should create a .tfstate file in the same directory

#7
Q: We have created another directory containing configuration files at '/root/terraform-project/christmas-wishlist'. 
Inspect this configuration directory.
N: Contains two configuration files, cyberpunk.tf and ps5.tf
# cyberpunk.tf
resource "local_file" "cyberpunk" {
  filename     = "/root/cyberpunk2077.txt"
  content  = "All I need for Christmas is Cyberpunk 2077!"
}

# ps5.tf
resource "local_file" "ps5" {
  filename     = "/root/ps5.txt"
  content  = "And a PS5!"
}


#8
Q: How many resources are configured within this configuration directory?
Make sure to check all the .tf files
A: 2, the "ps5" and "cyberpunk"


#9
Q: What is the filename that will be created by the resource called cyberpunk?
A. /root/cyberpunk2077.txt


#10
Q: Create a new configuration file within the same directory called 'xbox.tf'. This file should make use of the same 'local_file' resource type with the below requirements.
Resource name: xbox
filename: /root/xbox.txt
content: Wouldn't mind an XBox either!
Once the configuration file has been created, use the terraform workflow to create this resource
S: xbox.txt under /root/terraform-project/christmas-wishlist, the use init, plan, and apply commands of terraform

resource "local_file" "xbox" {
    filename = "/root/xbox.txt"
    content = "Wouldn't mind an XBox either!"
}


#11
Q: Now, navigate to the diretory '/root/terraform-project/provider-a'. We have downloaded a plugin in this directory. Identify the name and type of provider.
If the configuration files in this directory seems unfamiliar, do not worry, these are covered later in the course.
S: Checking the Linode, it seems that it is a company, which means it is possible that they have gone to the partner provider process with Hashicorp
A: Partner - linode


#12
Q: Now, navigate to the diretory '/root/terraform-project/provider-b'. We have downloaded a plugin in this directory. Identify the name and type of provider.
If the configuration files in this directory seems unfamiliar, do not worry, these are covered later in the course.
S: Community - ansible




179. Configuration Directory

Configuration directory
 > configuration directory refers to the directory where the .tf file(s) are located
 > this is also where we execute the terraform commands such as init, apply, plan, destroy
 > this directory is NOT LIMITED to a SINGLE .tf file. We can have as many configuration .tf file as we want
 
EX:
 > /root/terraform-local-file
	- local.tf
	- cat.tf
	
# local.tf
resource "local_file" "pet" {
	filename = "/root/pets.txt"
	content = "We love pets!"
}

# cat.tf
resource "local_file" "cat" {
	filename = "/root/cat.txt"
	content = "My favorite pet is Mr. Whiskers"
}
 
 
Handling Resource blocks and Configurations files
 > while we can create a .tf file for each resources, we could also create a SINGLE configuration file to contain these resources
 > a single configuration file can have an MANY NUMBER of configuration blocks that you need
 
EX:
# main.tf
resource "local_file" "pet" {
	filename = "/root/pets.txt"
	content = "We love pets!"
}

resource "local_file" "cat" {
	filename = "/root/cat.txt"
	content = "My favorite pet is Mr. Whiskers"
}


Common configuration files created
1. main.tf
	> main configuration file containing resource definitions
2. variables.tf
	> contains variable declarations
3. outputs.tf
	> contains outputs from resources
4. provider.tf
	> contains provider definition
	
	
	

180. Multiple Providers

Multiple providers in a single configuration file
 > in a single configuration file, we can also utilize two or more providers in them by creating resources with different providers
 > in example below, we can two providers, the 'local' and the 'random', through two different resources
 > as usual, we would need to install the plugins for these provider through 'terraform init' command
	- in the logs, we should see these plugins for different providers
	
 
EX: configuration file with two provieders
# main.tf
resource "local_file" "pet" {
	filename = "/root/pets,txt"
	content = "We love pets!"
}

resource "random_pet" "my-pet" {
	prefix = "Mrs"
	separator = "."
	length = "1"
}


NOTES:
1. With random_pet resource type, we can create random objects with identifier
	> this identifier is RANDOM, but we can configure the output through arguments to be passed like prefix, length, separator, etc
	> ex: random pet with properties [id=Mrs.hen]




181. Lab - Multiple Providers

#1
Q: Can we use multiple providers in the same configuration directory.
A: YES

#2
Q: We have a new configuration directory located at the path '/root/terraform-projects/multi-provider'. Inspect this directory and find out the number of providers initialized.
Do not run the 'terraform init' command yet!
A: 0, since we haven't run the 'terraform init' command, and no .terraform directory is present yet

#3
Q: Now, run the 'terraform init' command and inspect the .terraform/providers directory. Count the number of plugins download.
S: Execute command below, It should install two plugins
$ cd /root/terraform-projects/multi-provider
$ terraform init

#4
Q: How many plugins are available now in this configuration directory?
S: Check number of directory under '.terraform/providers/*/' in the configuration directory.
A: 2


#5
Q: Now, Navigate to the directory '/root/terraform-projects/MPL'. Create a new configuration file called 'pet-name.tf'. This file should make use of the 'local_file' and 'random_pet' resource type with the below requirements:

local_file resource details:
	Resource name = "my-pet"
	File name = "/root/pet-name"
	Content = "My pet is called finnegan!!"
	
random_pet resource details:
	resource name = "other-pet"
	length = "1"
	prefix = "Mr"
	Separator = "."
	
Once the configuration file has been created, use the terraform workflow to create this resource.

S: pet-name.tf below
resource "local_file" "my-pet" {
    filename = "/root/pet-name"
    content = "My pet is called finnegan!!"
}

resource "random_pet" "other-pet" {
    length = "1"
    prefix = "Mr"
    separator = "."
}


#6
Q: Now change into the directory '/root/terraform-projects/provider' and inspect the file 'cloud-provider.tf'. What is the 'instance_type' configured with the resource type called 'aws_instance'?
Don't worry if you are not familiar with the aws providers. We will cover it later on.
S: cloud-provider.tf content
resource "aws_instance" "ec2_instance" {
	  ami       =  "ami-0eda277a0b884c5ab" 
	  instance_type = "t2.large"
}


resource "aws_ebs_volume" "ec2_volume" {
	  availability_zone = "eu-west-1"
	  size  =    10
}
A: t2.large


#7
Q: What is the name of resource configured with the resource type 'kubernetes_namespace' in 'kube.tf' file within the same directory?
S: kube.tf file
resource "local_file" "data" {
	filename = "/root/k8s.txt"
	content = "kubernetes the hard way!"
}


resource "kubernetes_namespace" "dev" {
  metadata {
    name = "development"
  }
}
A: dev


#8
Q: Let's get some more practice! Now navigate to the directory path '/root/terraform-projects/provider-a'. Create a configuration file called 'code.tf'
Using the 'local_file' resource type, write the resource block with the below requirements into the file:

Resource name = iac_code
File name = /opt/practice
Content = Setting up infrastructure as code

When ready, only run the 'terraform init' command, we will run the 'terraform apply' command later on.+


#9
Q: We have made some changes to the configuration file. Are you able to run terraform apply command?
S: new 'code.tf' file

resource "local_file" "iac_code" {
	  filename = "/opt/practice"
	  content = "Setting up infrastructure as code"
}


resource "random_string" "iac_random" {
  length = 10
  min_upper = 5
}


A: NO. The error ' Error: Inconsistent dependency lock file' shows


#10
Q: This is because whenever we add a resource for a provider that has not been used so far in the configuration directory, we have to initialize the directory by running 'terraform init' command.
Lets do that now. Run 'terraform init' followed by 'terraform apply' command




182. Using Input Variables

Input Variable
 > with Input variables, we can define placeholders for values, and then use those placeholders instead of the actual values
 > advantages of using variables are:
	1. this will help us prevent hardcoding the values which is not the best practice
	2. improve the reusability of our configuration files
	3. single place to update informations


Creating Variables in Terraform
 > creating variable is similar to creating a resource, where we need to create a block, and the arguments inside them
 > to create a variable, we will need to use the 'variable' keyword, followed by the variable name
	- for variable names, we can use anything that we want, but it is preferred to use an appropriate name such as the argument name for which we are using the variable
 > inside the 'variable' block, we can provide a default value using the 'default' argument
	- default is an optional argument but it is a quick way to assign value

SYNTAX:
variable "VARIABLE NAME" {
	default = "VALUE"
}

EX:
variable "filename" {
	default = "/root/pets.txt"
}


Using variables in the resource blocks
 > to use variables in the resource block, we can use the 'var' keyword
 > var contains all the variables that we defined
 > in example below, we can see that the variables defined in 'variables.tf' is used in the 'main.tf' configuration file
 > after this, we can now use 'terraform plan' then 'terraform apply' after reviewing the actions
 > if we want to update variables to change the resource config, we can just update the value in the variable block, then do the 'terraform apply' again to reflect the changes

EX:
# variables.tf
variable "filename" {
	default = "/root/pets.txt"
}

variable "content" {
	default = "We love pets!"
}

variable "prefix" {
	default = "Mrs"
}

variable "separator" {
	default = "."
}

variable "length" {
	default = "1"
}

# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = var.content
}

resource "random_pet" "my-pet" {
	prefix = var.prefix
	separator = var.separator
	length = var.length
}


EX 2: AWS EC2 with variables
# main.tf
resource "aws_instance" "webserver" {
	ami				= var.ami
	instance_type	= var.instance_type
}

# variables.tf
variable "ami" {
	default = "ami-0edab43b6fa892279"
}

variable "instance_type" {
	default = "t2.micro"
}





183. Understanding the Variable Block

Variable block
 > variable block consist of several arguments
	1. default
	2. type
	
	3. description
 > default is the default value to be used when to  
 > description is a string, and describes the variable
	- optional, but it helps others understand the variable
	
Variable types
 > type refers to the type of the value the variable can hold
	- optional, if not specified, it will use 'any'
	- below is the list of types that can be used, some of these are
		Type		Example
		string		"/root/pets.txt"
		number		1
		bool		true/false
		any			default value
		list		["cat", "dog"]
		map			pet1 = cat
					pet2 = dog
		object		Complex Data Structure
		tuple		Complex data structure
	- for string, it accepts an alphanumeric string
	- for number, it accepts a single numeric value, and it can be either positive or negative
	- for bool, it accepts either true or false
	
ex:
# variables.tf
variable "filename" {
	default = "/root/pets.txt"
	type = string
	description = "the path of local file"
}

variable "content" {
	default = "We love pets!"
	type = string
	description = "the content of the file"
}

variable "prefix" {
	default = "Mrs"
	type = string
	description = "the prefix to be set"
}

variable "length" {
	default = "1"
	type = number
	description = "length of the pet name"
}

variable "password_change" {
	default = true
	type = bool
}
	
	
Complex variable types
List
	> list is a variable type that contains one or more entries
	> when using the list entries, we can use the index of the said entry
		- index starts with 0, meaning the third element for example is at index 2
	> the syntax to use the LIST_VARIABLE[INDEX]
	> in example below, we can see that we used the 0th index of the variable 'prefix', which is the 'Mr'
EX:
# variables.tf
variable "prefix" {
	default = ["Mr", "Mrs", "Sir"]
	type = list
}

# main.tf
resource "random_pet" "my-pet" {
	prefix = var.prefix[0]
}


Map
	> map is a variable type represented in key value pairs
	> in a map, we can define as many key = value pairs as we want, and they will be enclosed in a curly braces
	> when using a specific field in the map variable, we can use the syntax below
		var.MAP_VARIABLE["FIELD KEY"]
	> in example below, we can see that the 'content' arg of 'my-pet' resource uses the value of 'statement2' key of the map variable 'file-content'. This value will then be the 'We love animals!'

EX:
# variables.tf
variable file-content {
	type = map
	default = {
		"statement1" = "We love pets!"
		"statement2" = "We love animals!"
	}
}

# main.tf
resource local_file my-pet {
	filename = "/root/pets.txt"
	content = var.file-content["statement2"]
}


List and Map with constraints
List with Constraint
	> this is similar to a normal list, but we want added a type constraint so that the list can only have entries of specific type
	> to do this, we can use the syntax below for the 'type'
		- list(TYPE)
		- ex: list(string)
	> if we defined a value of list that does not match the constraint, the terraform commands 'plan' and 'apply' will throw error
	> in example below, the terraform plan will throw an error since the variable 'prefix2' does not match the constraint set in the list
	
EX 1:
# variables.tf
variable "prefix" {
	default = ["Mr", "Mrs", "Sir"]
	type = list(string)
}

variable "prefix" {
	default = [1,2,3]
	type = list(number)
}

variable "prefix2" {
	default = ["Mr", "Mrs", "Sir"]
	type = list(number)
}


Map with Constraint
	> we could also add constraint to the map
	> this will specific the allowed type of the values in each key value pairs
		- this means that all values will have the same type
	> same syntax applies, where below is the syntax and an example
		- type = map(TYPE)
		- ex: type = map(string)
EX:
# variables.tf
variable "cats" {
	default = {
		"color" = "brown"
		"name"	= "bella"
	}
	type = map(string)
}

variable "pet_count" {
	default = {
		"dogs" = 3
		"cats" = 1
		"goldfish" = 2
	}
	type = map(number)
}


Set
	> similar to a list, but we cannot have similar or duplicate entries
	> if similar entries are found in a set variable, it will throw an error
	> in example below, the "prefix2" will cause the config file to throw error
EX:
# variables.tf
variable "prefix" {
	default = ["Mr", "Mrs", "Sir"]
	type = set(string)
}

variable "prefix2" {
	default = ["Mr", "Mrs", "Sir", "Mr"]
	type = set(string)
}


Objects
 > with objects, we can create a complex data structure that consist of several key value pairs
 > unlike maps, we can see the constraint for each key value pairs (i.e. number for field1, then string for field2)

EX:
# variables.tf
variable "bella" {
	type = object({
		name = string
		color = string
		age = number
		food = list(string)
		favorite_pet = bool
	})
	default = {
		name = "bella"
		color = "brown"
		age = 7
		food = ["fish", "chicken", "turkey"]
		favorite_pet = true
	}
}


Tuples
 > similar to a list where it contains several entries
 > but unlike list where the entries must have same type, in tuples they can have different types
 > also, in tuples, we can only have specific number of entries, each with specific types based on the constraint defined
 
EX:
# variables.tf
variable "kitty" {
	type	= tuple([string, number, bool])
	default	= ["cat", 7, true]
}

# with incorrect entries
variable "kitty2" {
	type	= tuple([string, number, bool])
	default	= ["cat", 7, true, "dog"]
}





184. Lab: Variables

#1
Q: Which of the following is not a valid variable type?
A: item

#2
Q: Which one of the below is not a valid data type in terraform?
A: array

#3
Q: Navigate to the directory '/root/terraform-projects/variables'. Which type does the variable called number belong to?
S: Refer to the 'variables.tf' file content below
variable "name" {
     type = string
     default = "Mark"
  
}
variable "number" {
     type = bool
     default = true
  
}
variable "distance" {
     type = number
     default = 5
  
}
variable "jedi" {
     type = map
     default = {
     filename = "/root/first-jedi"
     content = "phanius"
     }
  
}

variable "gender" {
     type = list(string)
     default = ["Male", "Female"]
}
variable "hard_drive" {
     type = map
     default = {
          slow = "HHD"
          fast = "SSD"
     }
}
variable "users" {
     type = set(string)
     default = ["tom", "jerry", "pluto", "daffy", "donald", "jerry", "chip", "dale"]

  
}
A: bool

#4
Q: How would you fetch the value of the key called 'slow' from the variable called 'hard_Drive' in a terraform configuration?
This variable is defined in the file 'variables.tf'
A: var.hard_drive["slow"]

#5
Q: What is the index of the element called 'Female' in the variable called 'gender'?
A: 1

#6
Q: What is the type of variable called 'users'?
A: set(string)

#7
Q: However, this variable has been defined incorrectly! Identify the mistake.
A: Duplicate elements ("jerry")

#8
Q: We have now updated the 'main.tf' file in the same directory (/root/terraform-project/variables) and added some resource blocks.
Inspect tem.
S: main.tf file
resource "local_file" "jedi" {
     filename = "/root/first-jedi"
     content = "phanius"
}

#9
Q: What is the value for the argument called 'content' used in the resource block for the resource 'jedi'?
A: phanius

#10
Q: Now, let's update this resource and add variables instead. Use the default value declared in the variable called 'jedi'.
This variable is a map. For the argument called 'content' used the value of the key by the same name. And, similarly, for the argument called 'filename' use the value by the same name.
When ready, run 'terraform init, plan, and apply' to create the resource
S: Updated main.tf file below where we used 'jedi' variable in variables.tf file, execute commands above to create the resource
# main.tf
resource "local_file" "jedi" {
     filename = var.jedi["filename"]
     content = var.jedi["content"]
}


# variables.tf
variable "jedi" {
     type = map
     default = {
          "content" = "phanius"
          "filename" = "/root/first-jedi"
     }
}




185. Using Variables in Terraform

Methods of providing values for variables
1. Interactive mode
2. '-var' command flags in 'terraform apply command'
3. Environment variable that starts with 'TF_VAR_'
3. Variable definition files

Interactive mode for variables
 > if we provide a variable block with empty arguments, when we run the 'terraform apply' command, it will go into an interactive mode
 > in the mode, we will be prompted to provide values for each variables with NO default value
 
EX:
# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = var.content
}

resource "random_pet" "my-pet" {
	prefix = var.prefix
	separator = var.separator
	length = var.length
}

# variables.tf
variable "filename" {

}
variable "content" {

}
variable "prefix" {

}
variable "separator" {

}
variable "length" {

}



'-var' flag in 'terraform apply' command
 > with this flag, we can provide key=value pairs
 > we can pass as many -var flag to the command as we need
 > for each variable specified in the -var flags, it will create a similar variable whose name is the key, and value is the value
 
EX:
$ terraform apply -var "filename=/root/pets.txt" -var "content=We love Pets!" -var "separator=." -var "length=2"




TF_VAR_* environment variables
 > any environment that starts 'TF_VAR_' will be added as variable in the Terraform
 > the string after the 'TF_VAR_' prefix of the environment variable will serve as the variable name in terraform, and its value is the value of the env var
 > in example below, the variables 'filename', 'content', 'prefix', 'separator', and 'length' will be created
 
EX:
$ export TF_VAR_filename="/root/pets.txt"
$ export TF_VAR_content="We love pets!"
$ export TF_VAR_prefix="Mrs"
$ export TF_VAR_separator="."
$ export TF_VAR_length="2"
terraform apply



Variable definition files using terraform.tfvars, terraform.tfvars.json, *.auto.tfvars, or *.auto.tfvars.json
 > the contents of the *.tfvars file is similar to that of the HCL file, but it only consist of variable assignment
	- for *.tfvars.json files, it will have different syntax
 > all files that matches the files below are AUTOMATICALLY LOADED by Terraform
	- terraform.tfvars
	- terraform.tfvars.json
	- *.auto.tfvars (any file that ends with .auto.tfvars)
	- *.auto.tfvars.json (any file that ends with .auto.tfvars.json)
 > if we use a variable definition file that does not match the ones above, we will need to use the flag '-var-file'
 
EX:
# terraform.tfvars
filename = "/root/pets.txt"
content = "We love pets!"
prefix = "Mrs"
separator = "."
length = "2"

$ terraform apply

$ terraform apply -var-file variables.tfvars



Variable definition precedence
 > each method that we've specified do have precedence that it follows to determine which will take effect
 > below is the precedence order, the higher ones will take precedence to assign value to the variable
	PRECEDENCE		METHOD
	4				-var or -var-file (command-line flags)
	3 				*.auto.tfvars (alphabetical order)
	2				terraform.tfvars
	1				Environment variables
	
	
EX:
# main.tf
resource local_file pet {
	filename = var.filename
}
# variables.tf
variable filename {
	type = string
}

# via environment variable
$ export TF_VAR_filename="/root/cats.txt"

# via terraform.tfvars
filename = "/root/pets.txt"

# variable.auto.tfvars
filename = "/root/mypet.txt"

# via -var command flag
$ terraform apply -var "filename=/root/best-pet.txt"






186. Lab: Using Variables in Terraform

#1
Q: How can we use environment variables to pass input variables in terraform scripts?
A: TF_VAR_<variable_name>, the syntax of env var to be created

#2
Q: Which method has the highest priority in Variable Definition Precedence?
If unsure, refer to the documentation. Documentation tab is available at the top right.
A: command line flag of -var or -var-file

#3
Q: Which one of the following commands is a valid way to make use of a custom variable file with the 'terraform apply' command?
A: terraform apply -var-file variables.tfvars

#4
Q: We have created some files under the directory '/root/terraform-project/variables'. Inspect it,

# basket.auto.tfvars
filename = "/root/basketball.txt"

# main.tf
resource local_file games {
  filename = var.filename
  content = "football"
}

# terraform.tfvars
filename = "/root/football.txt"

# throw.auto.tfvars
filename = "/root/baseball.txt"


#5
Q: What will if we run terraform plan command right now?
A: Error, variable is not declared yet

#6
N: The terraform plan command did not run as there was no reference for the input variable called 'filename' in the configuration files. Lets fix that now

#7
Q: Declare the variable called 'filename' with type 'string' in the file 'variable.tf'
Do not have to specify a default value
S: contents of variables.tf below

variable "filename" {
    
}


#8
Q: If we run 'terraform apply' with a -var command line flag as shown below, which value would be considered by 'terraform'?
terraform apply -var filename=/root/tennis.txt
A: /root/tennis.txt

#9
Q: Terraform follows a variable definition precedence order to determine the value and the command line flag of -var or -var-file takes the highest priority.





187. Resource Attributes

Resource Attributes
 > these refers to the readable attributes of Resources
 > once 'terraform apply' command is executed, some created resources exposes a set of their attributes to be used by other resources
 > example is the 'random_pet' resource type, which exposes the 'id' attribute
 
 
Use case of Resource Attributes
 > as of now, we have created resources that have NO DEPENDENCIES with each other
 > the scenario RARELY happen, as we typically build infrastructure resources that have DEPENDENCIES with each other
 > example is when we create an AWS EC2 instance, and we want to associated that instance to a specific ElasticIP created
 

Referencing resource attributes to another resource
 > in order to use other resources' attributes, we will need to use the syntax below
	SYNTAX: ${RESOURCE_TYPE.RESOURCE_NAME.ATTRIBUTE}
	EX: ${random_pet.my-pet.id}
 
 > this syntax or experssion is known as INTERPOLATION SEQUENCE
	- basically, it first evaluate the expression.
	- then, it converts it to string
	- lastly, it will add it to the string where it is added
	

Example:
 > in example below, we are referencing the 'id' attribute of a random_pet resource named 'my-pet'

# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
}
resource "random_pet" "my-pet" {
	prefix = var.prefix
	separate = var.separator
	length = var.length
}





188. Lab: Resource Attributes

#1
N: Navigate to the configuration directory '/root/terraform-projects/project-chronos' and inspect the files created inside.

File 1: main.tf
resource "time_static" "time_update" {
}


#2
Q: What is the 'resource_type' of the resource that's currently defined in the 'main.tf' file?
If unsure, refer to the documentation. Documentation tab is avaialble at the top right panel.
A: time_static


#3
N: As you cna see, the resource block is empty. This is because time_static does not need any arguments to be supplied to work.
When applied as it is, terraform creates a logical resource locally (similar to random_pet) with the current time.


#4
Q: Which of the following attributes are exported by the 'time_static' resource?
If unsure, refer to the documentation. Documentatino tab is available at the top right panel.
A: id


#5
Q: How do we refer to the attribute called id using a reference expression?
A: time_static.time_update.id


#6
Q: Now, update the main.tf file and add a new 'local_file' resource called 'time' with the following requirements:
1. filename: /root/time.txt
2. content: Time stamp of this file is <id from time update resource>
Use a reference expression and interpolation
When ready, run terraform init, plan, and apply
S: Updated main.tf file

 resource "time_static" "time_update" {
}

resource "local_file" "time" {
    filename = "/root/time.txt"
    content = "Time stamp of this file is ${time_static.time_update.id}"
}


#7
Q: What is the attribute called 'id' that is created for the 'local file' resource called 'time'?
Make use of the 'terraform show' command and identify the attribute values
A: 8d51d78986eca017118c270fbb3576355bec4be2


#8
Q: What is the attribute called 'rfc3339' that is created for the 'time_static' resource called 'time_update'?
Make use of the 'terraform show' command and identify the attribute values.
A: 2024-02-25T13:22:07Z







189. Resource Dependencies


Resource Dependencies
 > often, the resources have dependencies from one or more resources
 > based on these dependencies, the Terraform will decide the order at which the resources will be created
	- ex: if resource A have dependency with resource B, resource B will be created first, followed by resource A

Types of Resource Dependency
 > there are two types of resource dependencies
	1. Implicit dependency
	2. Explicit dependency
 > for Implicit dependency, it is created when a resource is IMPLIED to have depedency to another resource
	- this is done through the use of resource attributes, where one resource references the attribute of another resource
	- Terraform can imply the dependencies through this
 > for Explicit dependency, it is created when we EXPLICITLY specified that a resource has a dependencies to other resources	
	- this is done through using the 'depends_on' attribute of the resource, and pass the RESOURCE_TYPE and RESOURCE_NAME of the dependency
	- we typically use this when a resource have an indirect dependency to other resource, and it DOES NOT make use of a reference expression as seen in this case
	- ex:
		depends_on = [ random_pet.my-pet ]
	
	
EX: Implicit depedency
# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
}
resource "random_pet" "my-pet" {
	prefix = var.prefix
	separate = var.separator
	length = var.length
}


EX: Explicit depedency
# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is Mr.Cat"
	depends_on = [
		random_pet.my-pet
	]
}
resource "random_pet" "my-pet" {
	prefix = var.prefix
	separate = var.separator
	length = var.length
}






190. Lab: Resource Dependencies

#1
Q: Which argument should be used to explicitly set dependencies for a resource?
A: depends_on

#2
Q: Resource A relies on another Resource B but doesn't access any of its attributes in its own arguments. What is this type of dependency called?
A: explicit dependency

#3
Q: How do we make use of 'implicit dependency'?
A: reference expressions

#4
Q: In the configuration directory '/root/terraform-projects/key-generator', create a file called 'key.tf' with the following specifications:
Resource type: 'tls_private_key'
Resource name: pvtkey
algorithm: RSA
rsa_bits: 4096
When ready, run terraform init, plan, and apply
If unsure, refer to the documentation.
S: key.tf content

resource "tls_private_key" "pvtkey" {
    algorithm = "RSA"
    rsa_bits = "4096"
}


#5
N: Resource 'tls_private_key' generates a secure private key and encodes it as PEM. It is a logical resource that lives only in the terraform state
You can see the details of the resource, including the private key by running the terraform show command
You can read the documentation for more details.
https://registry.terraform.io/providers/hashicorp/tls/latest/docs/resources/private_key



#6
Q: Now, let's use the private key created by this resource in another resource of type 'local file'. Update the key.tf file with the requirements:
Resource name: key_details
File name: /root/key.txt
Content: use a reference expression to use the attribute called 'private_key_pem' of the 'pvtkey' resource
When ready, run terraform init, plan, and apply
S: key.tf content

resource "tls_private_key" "pvtkey" {
    algorithm = "RSA"
    rsa_bits = "4096"
}

resource "local_file" "key_details" {
    filename = "/root/key.txt"
    content = "${tls_private_key.pvtkey.private_key_pem}"
}


#7
Q: Now destroy these two resources
Use 'terraform destroy'


#8
Q: For the next question, navigate to the directory /root/terraform-projects/explicit-dependency


#9
Q: Within this directory, create two 'local_file' type resources in 'main.tf' file
Resource 1:
	Resource name: whale
		Filename: /root/whale
		content: whale
Resource 2
	Resource name: krill
		Filename: /root/krill
		content: krill
Resource called 'whale' should depend on 'krill' but do not use reference expressions
When ready, run terraform init, plan, and apply
S: main.tf file content

resource "local_file" "whale" {
    filename = "/root/whale"
    content = "whale"
    depends_on = [ local_file.krill ]
}

resource "local_file" "krill" {
    filename = "/root/krill"
    content = "krill"
}





191. Output Variables

Output variables
 > output variables are varibles used for storing resources' attributes
 > below is the syntax on creating an output variable
 
SYNTAX:
ouput "<variable_name>" {
	value = "<variable_value>"
	<arguments>
}

EX:
# main.tf
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
}
resource "random_pet" "my-pet" {
	prefix = var.prefix
	separate = var.separator
	length = var.length
}
output pet-name {
	value = random_pet.my-pet.id
	description = "Record the value of pet ID generated by the random_pet resource"
}


Printing Terraform output variables
 > to print ALL output variables, use the command below
	$ terraform output
 > to print SPECIFIC output variable, provide the name after the command above
	$ terraform output VARIABLE_NAME
 > ex:
	$ terraform output
	pet-name = Mrs.gibbon



Use case for Output variables
 > since resource block can already access other resource's attributes via reference expression, using output variable in this case is not recommended
 > the popular use case for these are:
	1. quickly display details about a provision resource on the screen
	2. feed the output variables to other IAC tools such as Ansible or ADHOC script for configuration management or testing





192. Lab: Output Variables

#1
N: Navigate to the directory called '/root/terraform-projects/data'. We have used the configuration files created in this directory to create some resources. Inspect them

File 1: main.tf
resource "random_uuid" "id1" {
   
}
resource "random_uuid" "id2" {
   
}
resource "random_uuid" "id3" {
   
}
resource "random_uuid" "id4" {
   
}
resource "random_uuid" "id5" {
   
}
resource "random_uuid" "id6" {
   
}
resource "random_uuid" "id7" {
   
}
resource "random_integer" "order1" {
  min     = 1
  max     = 99999
 
}
resource "random_integer" "order2" {
  min     = 1
  max     = 222222
 
}


#2
Q: Which provider is used by the configuration files in this directory?
A: random


#3
Q: Which two resource types are configured in the configuration files?
A: random_uuid & random_integer


#4
N: We also defined a few output variables in the output.tf file in this configuration directory. Inspect them

File 2: output.tf
output "id1" {
   value = random_uuid.id1.result
}
output "id2" {
    value = random_uuid.id2.result
   
}
output "id3" {
    value = random_uuid.id3.result
   
}

output "id4" {
    value = random_uuid.id4.result
   
}
output "id5" {
    value = random_uuid.id5.result
}
   
output "id6" {
    value = random_uuid.id6.result
   
}
output "id7" {
    value = random_uuid.id7.result
   
}
output "order1" {
 value = random_integer.order1.result
 
}
output "order2" {
 value = random_integer.order1.result
 
}


#5
N: Run terraform init, plan, and apply to create these resource.


#6
Q: What is the value of the output variable called 'id2'?
Use the terraform output command
S: terraform output id2
A: 4651d1a1-9c66-1e75-da19-2a711fcbd943


#7
Q: What is the value of the output variable called 'order1'?
Use the terraform output command.
S: terraform output order1
A: 68199


#8
Q: We have a new configuration directory located at the path '/root/terraform-projects/output'. Inspect the configuration files that are created in this directory.
What is the value of the output variable 'pet-name'?
Use the terraform output command within the new configuration directory.
S: Files under /root/terraform-projects/output. Use 'terraform output pet-name'
A: drake
File 1: main.tf
resource "random_pet" "my-pet" {
  length    = var.length 
}

output "pet-name" {
	value = random_pet.my-pet.id
	description = "Record the value of pet ID generated by the random_pet resource"
}


File 2: variable.tf
variable "prefix" {
  default = "Mrs"	
}

variable "separator" {
	default = "."
}

variable "length" {
	default = "1"
}


#9
Q: We have just updated the main.tf file in this directory with a new resource block.
Add a new output variable with the following specifications:
Output variable name: welcome_message
Value: content of the resource called welcome
When ready, run terraform init, plan, and apply
S: new main.tf file content
resource "random_pet" "my-pet" {
  length    = var.length 
}

output "pet-name" {
	value = random_pet.my-pet.id
	description = "Record the value of pet ID generated by the random_pet resource"
}

resource "local_file" "welcome" {
    filename = "/root/message.txt"
    content = "Welcome to Kodekloud."
}

output "welcome_message" {
	value = local_file.welcome.content
	description = "Content of welcome text file"
}