Algolia 101 - A comprehensive and hands-on developer training from Data Ingestion to Front-End


Live coding: Indexing

Requirements:
1. Environment where NodeJS is installed
	> we can either use our local machine, or use online sandbox like "codesanbox.io"
2. Add "algoliasearch" library into the NodeJS project
	> either use:
		- npm i algoliasearch --save
		- yarn add algoliasearch --save
		

API keys in Algolia
 > by default, there are two API keys available
	1. Search-only API keys
	2. Admin API keys
 > we can also create our custom API keys with relevant access/permissions set to the said API keys
 
 
Fetching the API keys in Algolia
1. Go to the Dashboard of Algolia
2. Go to the Settings by clicking the Gear icon at lower left
3. In the Organization Settings, go the "Team and Access" -> "API keys"



Creating NodeJS app for Algolia indexing
1. Create new js file (index.js) in root directory of NodeJS project
2. Inside the index.js, do the following
	> initialize algoliasearch
		- const algoliasearch = require('algoliasearch')
	> create Algolia client using the imported algoliasearch, pass the App Id and Admin API Key into the constructor of Algolia client
		- const client = algoliasearch('ALGOLIA_ID', 'ALGOLIA_API_KEY');
	> create an Index using the Algolia client we created earlier, pass the name of the said index
		- const index = client.initIndex('glenn_movies');
3. Create a json file in the root directory to represent a Record
	> https://github.com/algolia/datasets/blob/master/devcon2023/movies.json
	> download the json file and add it to the root directory
4. Back to the index.js
	> import the JSON file as javascript object inside
		- const movies = require("./movies");
	> using the Algolia index object and the javascript object "movies", we can save objects in the said index
		- index.saveObjects(movies).then(() => console.log("That's all folks"));
5. Run the index.js. In the CLI, execute
	> node index.js
6. Look at the Algolia dashboard based on AppId and Index name used
	> we should that it is populated by records that corresponds to the "movies.json" that we used
	
	
Classes/Methods available in "algoliasearch" library
index.saveObjects(array objects)
index.saveObjects(array objects, object requestOptions)
index.saveObject(object objects)
index.saveObject(object objects, object requestOptions)
 > used to save an array of objects into the Index directly
 > we can also pass an object to configure the request options like
	- autoGenerateObjectIdIfNotExist: boolean
		= specifies if Algolia will create "objectId" attribute to record if it does not exist
 > this can either save or update a record in the Index, based on whether a Record with similar objectId exist
 
 
index.replaceAllObjects(array objects)
index.replaceAllObjects(array objects, object requestOptions)
 > used to replace ALL objects in the Index
 > used for doing FULL REINDEXING operation
 > Full reindexing operation works by:
	1. creating a temporary index to hold all the updated records
	2. once the reindexing is done, it will just switch the live and temporary index
 > requestOptions fields includes:
	- safe: bool
	

index.partialUpdateObjects(array objects)
index.partialUpdateObjects(array objects, object requestOptions)
index.partialUpdateObject(object objects)
index.partialUpdateObject(object objects, object requestOptions)
 > used for doing partial update on the records in Index
 > used for updating one or many attributes in the records of Index
 > requestOptions fields includes:
	- createIfNotExist: bool
	

index.deleteObjects(array objectIds)
index.deleteObjects(array objectIds, object requestOptions)
index.deleteObject(string objectId)
index.deleteObject(string objectId, object requestOptions)
 > used for deleting one or more records in the index
 > uses the object ids to locate the records to delete
 > more recommended to use than "index.deleteBy" due to performance efficiency
 
 
 
 
Update attribute of a Record
 > in this case, we want to update the popularity of a specific movie record in movies.json
1. In the root directory, create a json file
	> get one json object inside movies.json file, and paste it here
2. Modify the "popularity" attribute of the json object inside the newly created json file
3. Inside the index.js
	> import the json file which contains updated movie information into a javascript object
		- const spidermanNWH = require("SpidermanNWH");
	> call the saveObjects() of index, and pass an array with the json object inside
		- index.saveObjects([spidermanNWH]).then(() => console.log("Done."))
4. Run the index.js file by executing
	> node index.js
5. Check in the Algolia index if the value for record corresponding to the movie you updated has changed




WHAT IS A FACET?
https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#whats-a-facet
 > think of facets as a set of FILTERABLE CATEGORIES that allow users to refine results by multiple categories simultaneously.
 > Algolia derives these facets from attributes
	- for a book index, facets might be "author" or "genre" attributes
	- for a luxury shop, facets might be "brand" or "designer"
 > Algolia's faceting features allow you to:
	- List all possible values for selected attributes and return contexttual values and counts with each search result
	- Compute a facet count or the number of records matching each attribute's value
	- enable search within an attribute's values (search for facet values)




SETTING UP ATTRIBUTES FOR FACETING - DASHBOARD
1. Go to the Algolia Index dashboard
2. In the Index dashboard, select Configuration panel
3. From here, go to Filtering and Faceting -> Facets
4. In the "Attributes for faceting", add an Attribute
	- in our case, the "genre" attribute for movies
	
	
	
SETTING UP ATTRIBUTES FOR FACETING - API library - JavaScript
0. Remove any attributes we added for faceting earlier in dashboard
1. Go to the index.js
2. Using the index object, call setSettings()
	> pass an object with field "attributesForFaceting"
	> this attribute takes an array of string, corresponding to the name of the attributes to add for faceting
		- index.setSettings({attributesForFaceting: ["genres"]});
3. Execute the index.js file using
	> node index.js
4. Check in the dashboard if the settings reflected






BUILDING THE UI

Why FrontEnd? Because Milliseconds Matter
 > Algolia search library is focused on Frontend integration
 > Below are the following reasons as to why they focused on frontend integration instead of providing backend libraries for search feature
	1. Algolia's main goal is to have SMOOTH and almost INSTANT search experience which helps to convert searches into something
	2. In the search process, each additional step in the architecture brings computation time and network latency
	3. Building an As-You-Type search experience is most of the time too demanding for traditional backends while Algolia is tailored for it
 > Because of this, Algolia is the one doing the searching processes since they have servers tailored for this process

Can someone still go backend?
 > Yes they can, we can do this in two ways:
	1. With Algolia's frontend libraries, but using their servers as an endpoint to serve as proxy, they can leverage their own servers
	2. With their own frontend + backend development leveraging only the Algolia's client
		- to get all the value of Algolia, all request should be served live WITHOUT any cache
 > We typically do this if we want to enrich the response data of the Algolia search result
 > Also, in a typical search page, there will be multiple options to add in search like filters, categories, etc
	- with approach 1, Algolia's frontend libraries can take care of these easily
	- with approach 2, it will be much harder to do so
	
	
What Algolia Provides
 > 3 UI libraries
	1. InstantSearch
		- build your search result page
		- also include category page, product listing page, etc
	2. Autocomplete
		- build your search autocomplete menu
	3. Recommend
		- display recommended content
		
	
	
InstantSearch
 > use InstantSearch when:
	1. Search result page and all listing page (categories, brand pages, ...)
	2. full page or overlays
	3. single or multi index (federated search)
	4. Standard pagination or infinite scroll
 > available in 7 flavors
	- InstantSearch.js
	- React InstantSearch
	- React InstantSearch hooks
	- Vue InstantSearch
	- Angular InstantSearch
	- InstantSearch iOS
	- InstantSearch Android
	
	
Structure (Frontend)
 > consist of the following
	1. Rest APIs (Algolia)
		- Algolia Insights
		- Algolia Search
	2. Web
		-> API Client
			- SLA
			- Retries
			-> Algolia JS Helper
				- State (ex: search input, search result, etc)
				-> InstantSearch JS
					- Widgets
				-> InstantSearch React
					- Widgets
				-> InstantSearch Vue
					- Widgets
				-> InstantSearch Angular
					- Widgets
	3. Native Mobile
		-> Android API Client
			-> InstantSearch core for Android and Objective C
				-> InstantSearch for android
		-> Swift API Client
			-> InstantSearch for iOS
 > it all start with API clients from either Web or Native Mobile apps sending request to Algolia's REST APIs using their API clients
 
 
Widgets
 > Building blocks that have predefined behavior and render output
 > You can also style, extend or create custom widgets
 > you can test out these widgets here
	- https://www.algolia.com/doc/guides/building-search-ui/widgets/showcase/react/
	
	
Progressive Customization API
 > InstantSearch provides three layers of usage that get progressively more powerful, with each level giving you more control:
 > Widget progression includes:
	1. Predefined widgets:
		PROS: Up and running in seconds
		CONS: No access to the DOM output
	2. Extending widgets
		PROS: Take over control of the render output
		CONS: More coding required (outputted markup)
	3. Create custom widget
		PROS: Full control over the UI component as well as its render output
		CONS: Logic of widget must be coded
		
		
Insights
 > in order to build a good ranking strategy, in order to show proper item based on the context, we need to know about the user behavior. this includes:
	- knowing where the user is clicking
	- knowing where the user converts (from PLP to PDP)
 > Insight library helps us understand the user behavior, which in turn helps us to show more relevant content
	- Accenture said that 91% of consumers say they are more likely to shop with brands that provide offers and recommendations that are relevant to them 
 > Insights includes features that extends search capacities and used for learning user journey like
	- Neural
	- Dynamic ranking
	- Personalization
	- Recommend


How Algolia Insights works?
 > Algolia insights works by collecting "events" from the website/frontend, and using the data from the events to improve the Algolia Search and Algolia Recommend
 > Events can be either
	- View
	- Click
	- Conversion events
 > Event sources includes:
	- Mobile
	- PC
	- TV
	- Voice
 > Algolia Insights API processes these events to improve Algolia Search by:
	1. Click and Conversion Analytics
		- to track KPIs
	2. A/B Testing
		- to make informed decisions
	3. Dynamic Re-ranking
		- to leverage AI-driven merchandising
	4. Personalization
		- create unique experiences
	5. Neural
		- Better query understanding
 > Algolia Recommend is improved by Algolia Insights API using events to
	1. Determine Frequently Bought Together
		- increase order value
	2. Related/Trending Content
		- increase engagement
		
		
What should I track for Algolia Insights?
 > the bare minimum
	- Clicks and Conversions on Search result pages (or autocomplete)
	- Conversions on Product Detail Page (PDP) after search
		-> You will have to FORWARD the "queryID" to your PDP in order to track effectively
 > Extend user knowledge
	- Clicks on product cards (everywhere)
	- Content viewed
	- Listing page viewed
	- Conversion in all context (ex: outside site -> PDP)
	- Clicks on facets
	
	
What's a conversion
 > conversion is an action that proved that user had REAL INTEREST in that specific concept
 > eCommerce
	- Add to basket as main conversion
	- Final order as an additional events
	- Add to wishlist
 > Non eCommerce
	- Read (articles) using triggers like after X seconds, scroll position
	- Downloaded (software, PDFs...)
	- Watched (streaming
	
	
LIVE CODING: CREATING ALGOFLIX
Requirements
1. Environment that cna ho


Preparing index.html
1. Inside the index.html, import the following
	- src/index.js
2. Then add the algoliasearch and instantsearch js file in index.html
	- https://www.algolia.com/doc/guides/building-search-ui/installation/js/
	- copy the <script> tags in the "Directly in your page" section
	- this will make the "algoliasearch" and "instantsearch" available in the "window" object to be used
	
Final index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>InstantSearch</title>
    <script
      src="https://cdn.jsdelivr.net/npm/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"
      integrity="sha256-V3GHVlMSAsogT3wL0OY/l4d3fRLa56gNzlnzdIMBIWg="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.56.4/dist/instantsearch.production.min.js"
      integrity="sha256-U62jq/Jnfr93B4FQceG9WxzOg0o6WqJShZXL20/iKXQ="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <script src="src/index.js"></script>
  </body>
</html>


USING INSTANTSEARCH AND ITS WIDGETS
0. Go to index.js
1. Get the algoliasearch and instantsearch from the window object
2. Initialize "searchClient" object using "algoliasearch"
	> algoliasearch() takes two arguments
		- AppId
		- Read-only API key
	> assign the result on a variable
3. Initialize "search" object using the "instantsearch" object
	> instantsearch() takes an object, and this object needs to have the following fields
		- searchClient
		- indexName, string
5. Add a widget to show all the record hits
	> call the search.addWidgets()
	> inside addWidgets(), pass an array. and inside the array, pass instantsearch.widgets.hits()
		- this represent the "hits" widget 
	> inside hits(), pass an object with field "container"
		- the container represents the html element where the hits widget will be rendered
		- container takes a string value, which represents the id of the html element (ex: "#hits")
6. Add a widget to show a search bar
	> add another object inside search.addWidgets()
	> pass instantsearch.widgets.searchBox()
	> inside searchBox(), pass an object with field "container"
	> the value of container will be the id of the div that will contain the searchbox widget (ex: "#searchbox")
	> we can also specify the placeholder value to display while theres no input by passing "placeholder" field in the object
7. Go to index.html
8. Inside the <body> tag, create two div
	> 1st div will have id of "searchbox"
	> 2nd div will have id of "hits"
9. Restart the live server to host the index.html
10. We should see two things
	> search bar
	> json string which represent results
11. Try typing something in the search bar
	> the json string should be updated, and matches within the json string should be highlighted
