09 Application Deployment (Weather App)

Contents
61 Joining Heroku and GitHub
62 Version Control with Git
63 Exploring Git
64 Integrating Git
65 Setting up SSH keys
66 Pushing Code to GitHub
67 Deploying Node.js to Heroku
68 New Feature Deployment Workflow
69 Avoiding Global Modules








61 Joining Heroku and GitHub

GitHub
 > a provider of Internet hosting for software development and version control using Git. It offers the distributed version control and source code management functionality of Git, plus its own features
 >  a code hosting platform for version control and collaboration

Heroku
 > a platform as a service (PaaS) that enables developers to build, run, and operate applications entirely in the cloud.
 > can be used to deploy application with different languages (Node,js, Ruby, php, Java, etc)
 > to use the Heroku, we will need to use its CLI
 > follow the link below to know how to install the Heroku CLI
	- https://devcenter.heroku.com/articles/heroku-cli

Heroku commands
heroku -v
 > checks heroku version

heroku login
 > links our commands of heroku to our heroku account
 > with this, we can configure our apps in the local machine CLI













62 Version Control with Git

Git
 > a version control system used to manage application/source code versions
 > we can use this to serve as savepoints in our source code during development phase
 > with a version control, we can TRACK CHANGES in the source code

Git website
 > https://git-scm.com/










63 Exploring Git

Version Control with Git
 > in Git, there are four components
	1. Untracked files
	2. Unstaged Changes
	3. Staged Changes
	4. Commits

Untracked files
 > files that is not previously included in a commit
 > these includes files that are just added and hasnt been staged and committed
 > to make a file "tracked", we first need to included it in a commit

Unstaged Changes
 > refers to the changes mades to the files that is "tracked"
 
Staged Changes
 > refers to the added unstaged changes or untracked files
 > to add either unstaged changes or untracked file to the staged changes, we will need to use the command "git add"

Commits
 > synonymous to a "save point" of a source code
 > when we do a commit, ALL of the content of Staged Changes will be "saved" and be given a UNIQUE ID











64 Integrating Git

Git file
.gitignore
 > file that contains all the ignored files/folder for tracking
 > these files/folder will not be added to staged changes and be committed

Git commands used
git init
 > used to initialize (or reinitialize if one already exist) an empty local git repository on the directory where we executed the command
	- ex: if we use git init inside src, it will take all the files and folders inside src folder

git status
 > shows which files are 
	- untracked files, 
	- have unstaged changes	
	- staged changes

git add <directory>
 > used to add untracked files / unstaged changes to the staged changes
 > passing a dot to the directory will add EVERYTHING to staged changes

git commit
 > used to commit all staged changes
 > we can add several options like
	1. -m "<message>"
		- used for adding message to the commit
		- ex: git commit -m "Initial commit"


Color indication for files/folder
green with U
 > untracked files
green with A
 > untracked files in staged changes
yellow/orange with M
 > unstaged changes
default color
 > tracked files and no unstaged commits










65 Setting up SSH keys

SSH
 > stands for Secured SHell
 > gives us a mean to securely communicate to another machine

SSH key pair
 > contains a private key and public key

Creating SSH key pair
 > open the Git bash
 > execute the following command
	> $ ls -a -l ~/.ssh
	> if there is not content or any file pair (where the other is the same but with .pub extension), then you dont have a SSH key pair
 > to create a key pair, use the command
	> ssh-keygen -t rsa -b 4096 -C "glenneligio@gmail.com"

ssh-keygen 
 > command used to create ssh key pair
 > follwing options include
	1. -t
		- stands for type, we typically use "rsa" for the algorithm
	2. -b
		- stands for bit, defines the bits used for the key
		- we typically use 4096 bits
	3. -C
		- stands for comment, refers to the comment of the key
		- typically we add our email here
 > after executing the command, we will be ask different question
	1. the filename (default is id_rsa)
	2. enter passphrase (optional)
 > this will create two files, whose name is the filename we passed on questions
	- the one without .pub extension is the private key, which we will stored in our local machine and never share
	- the one with .pub extension is the public key, and anyone with this key can securely communicate with our local machine
		-> we will share this public key to GitHub and Heroku


SSH agent
 > SSH key manager that stores the SSH key in a process memory
 > to start the ssh agent in local machine, we will use the command
	eval $(ssh-agent -s)
 > if we already have the ssh agent running, it will print its process id 
 > then we can add the ssh key pair we made earlier in ssh agent using the command
	ssh-add -k ~/.ssh/id_rsa
 > if successful, it will log
	Identity added: /c/Users/glenn/.ssh/id_rsa (glenneligio@gmail.com)












66 Pushing Code to GitHub

Git Command:
git remote add <RepoName> <RepoUrl>
 > used to add a remote repository into our local git config

git push <remoteName> <branch>
 > used to push a branch to the specified remote git repo

Pushing Code to GitHub
1. Create a new GitHub repository
2. Add the new GitHub repo as one of remote git repo in our local git config
3. Setup GitHub account setting to the public SSH key we created earlier in one of its SSH key

Create a new GitHub repository
1. Click the plus icon
2. Select new repository
3. Give name to the new repository and leave the rest of configuration on default

Pushing our local repository to Github
 > to do this, we will use the command "git remote add"
	- this command is used to add a remote git repository
 > we will then push our local repository to this remote git repository we added
	git push origin -u master


Register our local machine's SSH public key to the GitHub account's SSH keys
1. Go to accounts
2. Go to Settings
3. Go to SSH and GPG keys
4. Click "New SSH key"
	- for title, pass any title
	- for key, pass the content of the public key

Connecting our local machine to the GitHub
 > In the GitBash, use the following command
	ssh -T git@github.com
 > we should see a success message 
	Hi GlennEligio! You've successfully authenticated, but GitHub does not provide shell access.












67 Deploying Node.js to Heroku

Heroku commands
heroku keys:add
 > used to add public SSH key to the heroku

heroku create <app-name>
 > used to create a herkou app using the project we are in
 > app-name should be unique across ALL HEROKU APP, not just your apps
 	- typically we use start with our name, then concatenate with the app name
 > note that we should execute this in the ROOT DIRECTORY/FOLDER of the project we want to use


Adding our local machines SSH public key to Heroku
 > to do this, we will use the commmand
	heroku keys:add
 > we will then be prompted to choose which public key to send
 > you should see a success message
	? Which SSH key would you like to upload? C:\Users\glenn\.ssh\id_rsa.pub
	Uploading C:\Users\glenn\.ssh\id_rsa.pub SSH key... done

Creating Heroku app
 > to create a Heroku app, we will need to use the command
	heroku create glenn-weather-application
 > note that we should be at the ROOT DIRECTORY/FOLDER of the project we want to use
 > this command will create TWO URLs
	1. first url is the url to visit in order to use/access the app
	2. second url is the git url where we should push the project that we want to deploy
 > if we visit the first url, we should see a "Heroku | Welcome" page
	- at this stage, we still HAVENT deployed our application

Setup our web-server project for Heroku deployment
 > before we deploy the project into the Heroku app git url, we will first configure it
 > specifically, we will do two things
	1. add a script and configure it so it executes "node src/app.js"
	2. setup the app so that it will listen to the port assigned by heroku
	3. change the url of fetch by just passing the relative url
 > by default, Heroku will execute "npm run start"
	- this means we need to add a "start" in the "scripts" of package.json file
	- then we will assign this the value of "node src/app.js"
	- with this, when Heroku executes "npm run start", it will run the web-server project
 > by default, Heroku will provide the port where the app should listen
	- this port value is given as Environment variable named PORT
	- this port value is also dynamic, it changes from time to time
	- with this, we need to setup our app in order to read the Environment variables available and assign it to the app.listen() call
	- for accessing Environment variable, we will use the process.env
		-> process.env contains all environment variables in key: value pairs
 > by passing just the relative url in fetch request, it will automatically use the local ip address of the machine it is currently running

EX:
// package.json
{
  "name": "web-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.1",
    "hbs": "^4.2.0",
    "postman-request": "^2.88.1-postman.31"
  }
}


// inside src/app.js
const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log("Server is up on port 3000");
});


// inside public/js/app.js
weatherForm.addEventListener("submit", (event) => {
  event.preventDefault();

  const location = search.value;

  messageOne.textContent = "Loading...";
  messageTwo.textContent = "";

  fetch("weather?address=" + location).then((response) => {
    response.json().then((data) => {
      if (data.error) {
        messageOne.textContent = data.error;
        messageTwo.textContent = "";
        return;
      }
      messageOne.textContent = data.location;
      messageTwo.textContent = data.forecast;
    });
  });
});


Deploy Node.js to Heroku
 > after configuring the Node.js for Heroku deployment, we will push the changes to the GitHub repo
 > we will now push this project to the remote git repo Heroku gave us earlier
	- not only it showed us the remote git url, it also added this in our local git config's remote git repo list
	- if we use "git remote" command, we will be shown the list of remote git repo
 > to push, we will use the command
	git push heroku master
 > if we look at the logs, we can see that it executed the "npm run start" command
	- it also show us the url to visit our application
	- https://glenn-weather-application.herokuapp.com/

EX:
// Console log of git push heroku master
Enumerating objects: 41, done.
Counting objects: 100% (41/41), done.   
Delta compression using up to 16 threads
Compressing objects: 100% (36/36), done.
Writing objects: 100% (41/41), 52.58 KiB | 5.84 MiB/s, done.
Total 41 (delta 6), reused 0 (delta 0), pack-reused 0
remote: Compressing source files... done.
remote: Building source:
remote: 
remote: -----> Building on the Heroku-20 stack
remote: -----> Determining which buildpack to use for this app
remote: -----> Node.js app detected
remote:        
remote: -----> Creating runtime environment
remote:
remote:        NPM_CONFIG_LOGLEVEL=error
remote:        NODE_VERBOSE=false
remote:        NODE_ENV=production
remote:        NODE_MODULES_CACHE=true
remote:
remote: -----> Installing binaries
remote:        engines.node (package.json):  unspecified
remote:        engines.npm (package.json):   unspecified (use default)
remote:
remote:        Resolving node version 16.x...
remote:        Downloading and installing node 16.15.1...
remote:        Using default npm version: 8.11.0
remote:        
remote: -----> Installing dependencies
remote:        Installing node modules
remote:        
remote:        added 113 packages, and audited 114 packages in 2s
remote:
remote:        9 packages are looking for funding
remote:          run `npm fund` for details
remote:
remote:        found 0 vulnerabilities
remote:        
remote: -----> Build
remote:        
remote: -----> Caching build
remote:        - npm cache
remote:        
remote: -----> Pruning devDependencies
remote:        
remote:        up to date, audited 114 packages in 414ms
remote:
remote:        9 packages are looking for funding
remote:          run `npm fund` for details
remote:
remote:        found 0 vulnerabilities
remote:        
remote: -----> Build succeeded!
remote: -----> Discovering process types
remote:        Procfile declares types     -> (none)
remote:        Default types for buildpack -> web
remote:
remote: -----> Compressing...
remote:        Done: 34.7M
remote: -----> Launching...
remote:        Released v3
remote:        https://glenn-weather-application.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/glenn-weather-application.git
 * [new branch]      master -> master












68 New Feature Deployment Workflow

New Feature Deployment Workflow
 > assumming we already have local git repository set up, the workflow when deploying new feature includes
	1. Creating/Adding feature to the source code
	2. If success, add the changes and commit them to GitHub
	3. We then push the changes to the Heroku remote git as well
	4. Check for the changes in the Heroku app public url










69 Avoiding Global Modules

Avoiding Global Modules
 > Global Modules are install directly into OS
 > This means that it will not be included in the package.json dependencies
	- for this reason, when we transfer the project to another machine and the project uses a global module, just running "npm install" will not suffice
	- we will need to explicitly install the global module it depends on
	- the global module may also be using different version which can cause problems
 > to address this, we may either
	1. add them as dependencies of the project
	2. add them as devDependencies of the project
 > with devDependencies, it will NOT BE INSTALL in the production environment

Installing a module as devDependency
 > to install a package as devDependency, we will need to add "--save-dev" flag
 	npm install <package> --save-dev

Creating Script for running specific long command
 > right now, if we want to run the web-server with nodemon, we need to use the nodemon command
 > but, same with the "npm run start" script, we can also make a script to execute this nodemon command

EX:
// inside package.json
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js -e js,hbs"
  },


NOTE:
1. Scripts in package.json can access locally installed dependencies





