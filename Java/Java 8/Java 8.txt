Java 8
	
New Features of Java 8
Lambda expression
Functional interface
Interface's defaults and static method
method references
steram api
date time api


Static Imports
	> used in order to omit the static Classes in source code

EX:
import static java.lang.System.*;

out.println("Square root of number is: ")


Lambda Expression and Functional Interface

Lambda Expression
	> anonymous or nameless methods
	> consist of the two components
		1. parameter list
		2. expression
	> helpful in Collection
		- iterating
		- filtering
		- extracting

SYNTAX
	> optional type declaration
	> optional parenthesis around parameter
	> optional curly braces
	> optional return keyword

(parameters) -> expression
(parameters) -> {statements;}
() -> expression


EX:
(int a, int b) ->    a * b      	// takes two integers and returns their multiplication
() -> 99                      		// takes no values and returns 99
(String a) -> System.out.println(a)   	// takes a string, prints its value to the console, and returns nothing
	

RULES IN WRITING LAMBDA EXPRESSION
PARAMETERS
1. Lambda expression can have zero, one, or more parameters
2. Type of parameters can be explicitly declared or can be INFERRED from the context
3. If lambda expression have MULTIPLE parameters, a parenthesis is MANDATORY
4. Empty parenthesis for empty parameters
5. If one parameter and type is inferred, parenthesis is OPTIONAL

METHOD BODY
1. Body can contain zero, one, or more statements
2. If body has ONE statement, curly brackets are OPTIONAL
3. If body has TWO or more statement, curly brackets are MANDATORY


WHY LAMBDA EXPRESISON?
	> Enable to treat functionality as a method argument, or code as data
	> function can be treated without belonging to a class
	> lambda expression can be passed around as if it was an object and execute on demand



Functional Interface (FI)
	> interfaces with only one abstract method
		- methods from Object class (equals, toString) dont count
		- get compile error when you define more than one abstract method
	> can be annotated with @FunctionalInterface, OPTIONAL
	> can have static and default methods inside
		- they do not count as method for Functional Interfaces


Static methods in Interface
	> methods that have ONLY ONE implementation	
	> can be called using the Interface itself
	

Default methods in Interface
	> methods that have a default implementation inside it
		- this implementation will be used in case the default method is not overriden
	> these methods can be overriden OPTIONALLY when we implemented the interface



Examples of Functional Interfaces
1. Predicate	
	> public interface Predicate<T> { boolean test(T t); }
	> performs a test that returns true or false 
	> test() takes a single Object parameter and returns a boolean 
	> the lambda expression below is the implementation of Predicate interface with its test()
	> removeIf() of Collection and filter() of Stream interface takes a Predicate object

EX: 
	Predicate<Integer> as Lambda
	list.removeIf(i -> i%2 == 0);


2. Function interface
	> public interface Function<T, R> { R apply(T t); }
	> applies a computation on ONE parameter and returns a result
	> apply() takes an Object and make modifications on it, it will then return the modified Object
	> below, we can see it used in the Comparator.comparing()

EX: Function<Thread, String> as lambda expression passed to comparing()

		List<Thread> threads = new ArrayList<>(Arrays.asList(new Thread("Larry"), new Thread("Jacob"), new Thread("Moe")));
		System.out.println(threads);
		threads.sort(Comparator.comparing((t) -> t.getName()));


3. BiFunction interface
	> public interface BiFunction<T, U, R> { R apply(T t, U u); }
	> applies a computation on TWO parameters and returns a result
	> below, we used BiFunction<String, Integer, Integer> in order to modify the Values in the Map Entries

EX: BiFunction<String, Integer, String> as lambda

		Map<String, Integer> iqMap = new HashMap<String, Integer>(){
			{
				put("Larry", 100);
				put("Curly", 100);
				put("Moe", 100);				
			}
		};
		iqMap.replaceAll((k,v) -> v-50);



4. Consumer Interface
	> A Consumer accepts a parameter & returns no result
	> Can be compared to Runnable Interface
	> public interface Consumer<T> { void accept(T t); }
	> below, we can see the Consumer<Thread> uses the Thread input and prints it out using println

EX:	Consumer<Thread> as lambda

		List<Thread> threads1 = new ArrayList<>(Arrays.asList(new Thread("Larry"), new Thread("Curly"), new Thread("Moe")));
		
		// Using lambda
		Consumer<Thread> con = n -> System.out.println(n);;
		threads1.forEach(con);
		threads1.sort(Comparator.comparing(Thread::getName));


5. Supplier Interface
	> A Supplier returns a value and take NO parameters
	> public interface Supplier<T> { T get(); }
	
EX: Supplier<String> as lambda in orElseGet() of Optional object

		Map<String, String> personMap = new HashMap<String, String>(){
			{
				put("Demon", "Naughty");
				put("Angel", "Nice");
			}
		};
		
		String person = "...";
		Optional<String> disposition = Optional.ofNullable(personMap.get(person));
		System.out.println("Disposition of " + person + " = " + disposition.orElseGet(() -> "unknown"));




Lambda Expression use in Functional Interface (FI)
	> with Functional Interface having only ONE abstract method, we can use Lambda Expression to define that single method
	> when we use Lambda Expression for instantiating a Functional Interface;
		- the parameter list in lambda will be the parameter we pass on the method of FI
		- the method body of lambda will be the method body of the "overridden" method of FI

EX: 
		// with Java 8 Lambda
		new Thread(() -> System.out.println("Lambda")).start();
		
		// before Java 8
		new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("Without Lambda");
			}
		}).start();


METHOD REFERENCES
	> method reference is a compact, easy-to-read handle for a method that already has a name
	> there are 4 kinds of method reference
		1. Reference to a static method
			> will call the static method of the said class
				SYNTAX:	ContainingClass::staticMethodName
				ex: String::valueOf	from 	s-> String.valueOf()
		2. Reference to an instance method of a particular object
			> will call the instance method of the given object
				SYNTAX:	containingObject::InstanceMethodName
				EX: 	s::toString	from	s -> s.toString()
		3. Refereance to an instance method of an arbitrary object of a particular type
			> will call instance method of object with specific dataType
				SYNTAX:	ContainingType::methodName
				EX:	String::toString	from 	s -> s.toString()
		4. Reference to a constructor
			> will make an instance of the said Class
				SYNTAX:	ClassName::new
				EX: 	String::new		from 	s -> ()
			




Streams API
	> defined as a sequence of elements form a source that supports aggregate operations on them.
	> source refers to Collections or Arrays

Aggregate Operations
	> also called bulk operations
	> performs a function
		- written in lambda expression or method reference
	> is a higher order function that applies a "behavior" parameter to every element in a stream
	> behavioural parameterization simplifies coping with changing requirements
	> allows us to express common manipulations on stream elements easily and clearly
	> aggregate operation in a stream runs its function sequentially 
		- SYNCHRONIZE, SINGLE THREAD


Stream
	> pipeline of aggregate operations that process a sequence of elements (aka, "values" or "data")
	> a conceptually fixed data structure, in which elements are computed on demand
		- hold NO NON-TRANSIENT storage
	> idea is that a user will extract only the values they require from a Stream, and these element are only produced
	> Characteristics
		- not a data structure
		- designed for lambdas
	> design for processing data
	> steps
		1. starts with source of data
			- data is preferred to be IMMUTABLE
		2. process the data through a PIPELINE of INTERMEDIATE operations
		3. Finishes with a TERMINAL operation
	> implementation of PQSA1 Pipes & Filters pattern
	> uses "internal" iterators 
		- compare to "external" iterators used by Collections

TYPES OF AGGREGATE OPERATIONS
	> Intermediate operations
	> Terminal operations

INTERMEDIATE OPERATIONS
	> process elements in their input stream & yield an output stream	
	> intermediate operations are "lazy" & don't run until a terminal operator is reached
TERMINAL OPERATION
	> triggers processing of the aggregate operations in a stream
	> each Stream MUST HAVE ONE AND ONLY ONE terminal operator


Streams structure

	-> Source (Collection)
		- Input x
	-> Aggregate operation (behavior f)		
		- Output f(x)
	-> Aggregate operation (behavior g)
		- Output g(f(x))
	-> Aggregate operation (behavior h)
		- Output h(g(f(x)))


EX:
		/*
		 *  Print each character in Hamlet that starts with
		 *  'H' or 'h' in ALL CAPS & sorted order
		 */
		
		Stream.of("Orphelia", "Horatio", "laertes", "Gertrude", "Hamlet", "fortinbras")
		.filter(s -> s.toLowerCase().charAt(0) == 'h')
		.map(m -> m.toUpperCase())
		.sorted()
		.forEach(System.out::println);
	
EX 2:
		stream()
		filter(not(this::urlCached))
		map(this::downloadImage)
		flatMap(this::applyFlters)
		collect(toList())


WHY Java Stream?
1. Concise and readable
	> declarative paradigm focuses on WHAT functions to perform, not HOW to perform them
	> no Java control-flow opeartions are applied in stream
2. Flexible
	> functions are automatically composed together
	> the output from filter is passed as the input to map()
3. Scalable
	> Parallelize performance without the need to write any multi-threaded code
	> with this, we will need to use ParallelStream object instead of Stream



COMMON STREAM AGGREGATE OPERATIONS

Stream filter(Predicate<T> pred)	
	> INTERMEDIATE operation
	> tests the given predicate against each element of the input stream 
	> returns an output stream consisting only of elements that match or "passed" the predicate
	> takes a Predicate object
		- this Predicate object can be written in lambda expression
	> number of output stream elements MAY BE LESS THAN the number of input stream elements

Stream map(Function<R, T> mapper)
	> INTERMEDIATE operation	
	> applies the given function to the elements of the input stream & returns an output stream consisting of the results
	> accepts Function object		
		- can be written in lambda expression or method reference
	> number of inputs elements on stream = number of outputs elements on stream
			
R collect(Collector<> collector)	
	> TERMINAL operation
		- triggers the processing of other aggregate operations in the stream
	> uses a Collector to perform a reduction on the elements of its input stream
	> returns the result of the reduction
	> used to "collect" the resulting Stream into a Collection/List/Set/Queue
		- will depend on what method you call in Collector parameter

Stream sorted()			
	> used to sort the element in Stream

int count()				
	> returns the number of element in Stream
	> if theres a filter() before count(), it will only count those element that passed the stream

Stream<T> peek(Consumer<T>)
	> with peek, we can use the elements of Stream to do certain action (i.e. printing the Elements)
	> will return the same Stream that it receives





DATE AND TIME API

Limitations of Date Time API BEFORE Java 8
1. Not thread safe
	> java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date
	> now, DateTime API is immutable and does not have setter methods

INSTEAD OF

Customer customer = new Customer();
Date d = customer.getCreationDate();
d.setTime(0L);

We will need a defensive copy:
public class Customer{
	private Date creationDate;
	public Date getCreationDate(){
		return new Date(this.creationDate,getTime());	
	}	
}


2. Not up to mark with regards to performance
3. Not convenient to use
	> Default date starts from 1900, months start from 1, and day starts from 0
	> this results in no uniformity

EX:
	Calender cal = Calendar.getInstance()
	// Sets Calendar to May 14, 2014
	cal.set(2014,4,14) 

4. Difficult time zone handling



NEW PACKAGES IN DATE TIME API
1. Instant (java.time.Instant)
	> Instant is a point in timeline
	> IMMUTABLE object

EX:	
	Instant i = Instant.now();
	// Outputs 2020-07-32T15:02:48.635Z

	> Z indicates the time is Coordinated Universal Time (or UTC)
	> Instant.MIN give an output of 1 billion years ago
	> Instant.MAX gives an output of Dec 31 of year 1,000,000,000



2. Duration
	> period of TIME between two Instant object
	> methods:
		Duration 	between(Instance i1, Instant i2)	returns the time based difference

EX:
		Instant i1 = Instant.now();
		Instant i2 = Instant.now();
		Duration d = Duration.between(i1, i2);
		d.getNano();



3. LocalDate
	> returns the date WITHOUT a timezone in it
	> 1999-04-24
   Period
	> represents the difference in amount of time using DATE-BASED VALUES in ISO-8601 period formats
		- PnYnMnD and PnW
	
EX:
		LocalDate currentDate = LocalDate.now();
		LocalDate birthDay = LocalDate.of(1999, 4, 24);
		Period p = Period.between(birthDay, currentDate);
		System.out.println("My age is: " + p.getYears());

NOTE:
Period deals with DATE BASED amount of time
Duration deals with TIME BASED amount of time



4. LocalTime 
	> print time without timezone in ISO-8601 format
	> hh:mm:ss.nnnn -> 12:24:36.0001
   LocalDateTime
	> prints time and date without timezone in ISO-8601 format
	> just a combination of LocalDate and LocalTime
	> 1999-04-24 12:24:36.0001

EX:
		LocalTime currentTime = LocalTime.now();
		System.out.println("Current time" + currentTime);
		LocalDateTime currentDateTime = LocalDateTime.now();
		System.out.println("Current Date and Time: " + currentDateTime);
		LocalDateTime birthDateTime = LocalDateTime.of(1999, 4, 24, 12, 24, 36);
		System.out.println("My birth date and time is: " + birthDateTime);




5. DateTimeFormatter
	> Formatter for printing and parsing date-time objects.
	> theres 3 different implementations of DateTimeFormatter
		a. Using predefined constants, such as ISO_LOCAL_DATE
		b. Using pattern letters, such as uuuu-MMM-dd
		c. Using localized styles, such as long or medium
	> for more information, visit
		- https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html

EX: 
		DateTimeFormatter dtFormat = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
		LocalDateTime lDt = LocalDateTime.of(1999, 4, 24, 12, 24);
		System.out.println("Birthday without DateTimeFormatter: " + lDt);
		System.out.println("Birthday with DateTimeFormatter: " + lDt.format(dtFormat));


6. Year
	> represents a particular year
	
EX:
		Year y = Year.now();
		System.out.println("Is the current year a leap year? " + y.isLeap());



7. ZoneId 
	> time-zone ID
	> for Manila, its "Asia/Manila", which is UTC+8
   ZonedDateTime
	> A date-time with a time-zone in the ISO-8601 calender system
	> immutable representation of a date-time with a time-zone
	> ex: 2007-12-03T10:15:30+01:00 Europe/Paris.

EX: 
		ZoneId ph = ZoneId.of("Asia/Manila");
		ZonedDateTime zDt = ZonedDateTime.now(ph);
		System.out.println("Time in Ph is: " + zDt);





