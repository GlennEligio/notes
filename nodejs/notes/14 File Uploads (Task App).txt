14 File Uploads (Task App)

Content:
123 Adding Support for File Uploads
124 Validating File Uploads
125 Validation Challenge
126 Handling Express Erros
127 Adding Images to User Profile
128 Serving up Files
129 Auto-Cropping and Image Formatting









123 Adding Support for File Uploads

Adding Support for File Uploads
 > by default, Express DOES NOT support file upload feature
 > but, we have an npm module that help us add this feature, the "multer"

multer
 > is a node.js middleware for handling "multipart/form-data", which is primarily used for UPLOADING FILES. 
 	- It is written on top of busboy for maximum efficiency.
 > to install this module, use the command
	- npm i multer

Function/Objects in multer library
multer
 > top level function that "multer" library exports
 > this function is the constructor of the multer Middleware
 > takes an "options" object to configure the middleware whose properties include
	1. dest or storage	
		> takes a string input
		> Where to store the files
		> when this is defined, the file binary data will NOT BE STORED in the req.file of the succeeding handlers through req.file.buffer
	2. fileFilter		
		> Function to control which files are accepted
	3. limits		
		> Limits of the uploaded data
		> takes an object which configures the limitation like
	4. preservePath		
		> Keep the full path of files instead of just the base name

Multer.prototype.single(fieldname: string)
 > function used to create a middleware that fetch a SINGLE file in "multipart/form-data" with same KEY name
 > the file information can then be access through the "req.file"


Using "multer" module
1. Import the multer module
2. Create a Multer instance using the constructor function exported by the multer module
	- we can pass an options object to configure this Multer instance
3. Create a middleware instance using the instance method of Multer and register it to either Application, Router, or to an individual Route
	- we can use single() to pick a single file the "multipart/form-data" of the request

Testing "multer" by sending request with file using Postman
 > to send a Request with file, we will need to make the body of Request to either
	- "form-data"
	- "multipart/form-data"
 > we can then set the data that we will add to form-data to either a "text" or a "file"
	- if we choose "file", it will give us a button to upload the file

EX:
In this example, we will be putting the "avatar" file in the "images" folder of workspace

// Using "multer" module
const multer = require("multer");
const upload = multer({
  dest: "images"
})

router.post("/users/me/avatar", upload.single("avatar"), (req, res) => {
  res.send();
});
 
 











124 Validating File Uploads

Function/Objects used
limits
 > a property to the options object we pass on constructor of Multer
 > defines the limitation of the file uploads which includes
	1. fieldNameSize	
		> Max field name size	
		> default is 100 bytes
	2. fieldSize	
		> Max field value size (in bytes)	
		> default is 1MB
	3. fields	
		> Max number of non-file fields	
		> Infinity
	4. fileSize	
		> For multipart forms, the max file size (in bytes)	
		> default is Infinity
	5. files	
		> For multipart forms, the max number of file fields	
		> default is Infinity
	6. parts	
		> For multipart forms, the max number of parts (fields + files)	
		> default is Infinity
	7. headerPairs	
		> For multipart forms, the max number of header key=>value pairs to parse	
		> default is 2000

fileFilter
 > a property in the "options" object that we pass to the Multer constructor function
 > takes a function which receive three arguments
	1. the request
	2. object that contains information about the file (Multer.File)
	3. callback used to define if the filter will be a success or not
 > the callback argument have THREE OVERLOADS
	1. cb(error: Error)
		- takes an Error instance
		- denote that somethings went wrong to request with file, and rejects the request itself
	2. cb(error: null, acceptFile: boolean)
		- receives null for first argument
		- second boolean argument defines if the file will be accepted or rejected
		- the request will still be process

Multer.File or File
 > object with contains several information about the file from "multipart/form-data" that is being processed
 > these contains properties like
	1. fieldname	
		> Field name specified in the form	
	2. originalname	
		> Name of the file on the user's computer	
	3. encoding	
		> Encoding type of the file	
	4. mimetype	
		> Mime type of the file	
	5. size	
		> Size of the file in bytes	
	6. destination	
		> The folder to which the file has been saved	
		> stored the file in the disk using DiskStorage engine
	7. filename	
		> The name of the file within the destination	DiskStorage
	8. path	
		> The full path to the uploaded file	DiskStorage
	9. buffer	
		> A Buffer of the entire file	
		> stored the file as Buffer objects in memory using MemoryStorage engine

String.prototype.match(regex: regex): boolean
 > checks if the string input matches the regex pattern
 > returns true if it match, else false

String.prototype.endsWith(subString: string)
 > checks if the string ends with specified substring
 > returns true if it match, else false



Validating File Uploads
 > there are numerous ways to validate the file uploads using multer
 > to do these, we will need to define the "limits" property to the options object we pass when we create an instance of Multer
 > this "limits" takes several properties like 
	- filesize, fieldSize, fileNameSize, etc 
 > we can also use the "fileFilter" function in options object in order to validate the file with its individual property like
	- filename, mime type, encoding, size, originalname, etc

EX:
// Multer instance configuration with validations
const upload = multer({
  dest: "images",
  limits: {
    fileSize: 1000000,
  },
  fileFilter(req, file, cb) {
    if (!file.originalname.match(/\.(doc|docx)/)) {
      cb(new Error("Please upload doc or docx files only"));
    }

    cb(null, true);
  },
});











125 Validation Challenge

GOAL:
1. Add validation to the avatar upoload route
	> limit of upload size to 1MB
	> only allow jpg, jpeg, png files

EX:
// Multer instance config
const upload = multer({
  dest: "images",
  limits: {
    fileSize: 1000000,
  },
  fileFilter(req, file, cb) {
    if (!file.originalname.match(/\.(jpg|jpeg|png)/)) {
      cb(new Error("Please upload only jpg, jpeg, and png files only"));
    }

    cb(null, true);
  },
});








126 Handling Express Erros

Function/Object used
app.get(path: string, middleware: function, requestHandler: function, errorHandler: function)
router.get(path: string, middleware: function, requestHandler: function, errorHandler: (error, req, res, next) => {})
 > another overload of the route methods of Application and Router
 > this overload have another parameter, the "errorHandler" parameter
 > errorHandler parameter have the following properties
	-> function that receives exactly FOUR ARGUMENTS
		1. error thrown during request processing (middleware or request handlers)
		2. the request
		3. the response
		4. the next route/middleware function
	-> these parameters MUST BE DEFINE
		- this is to let Express know that this function argument is an ERROR HANDLER function


Handling Express Errors
 > the default error handling behavior of the Express is that it will SEND AN HTML page with the error inside
 > but, using another overload of the route methods (i.e. app.get(), router.post()), we can setup an errorHandler function that can access error, request, response, and the next router/middleware function to GRACEFULLY HANDLE THE ERROR

EX:
// Route for "/users/me/avatar"
router.post(
  "/users/me/avatar",
  upload.single("avatar"), // middleware
  (req, res) => {
    // requestHandler
    res.send();
  },
  (error, req, res, next) => {
    // errorHandler
    res.status(400).send({ error: error.message });
  }
);








127 Adding Images to User Profile

Function/Objects used
req.file.buffer
 > buffer is a property to the Multer.File instance which contains the binary data of the file uploaded
 > this will only show IF we dont specify the "dest" or "storage" in the options object we pass in the Multer instance constructor

<img src="data:iamge/jpg;base64,{base64 binary data}">
 > format for the "src" property of the img tag
 > we need to provide the base64 binary data of the image inside curly braces
	- also, remove the curly braces

Adding Images to User Profile
 > right now, we are storing the uploaded files in the project file system
 	- but in production settings, the file system is often being RESET and with this, the data/files will be lost as well
 > to solve this issue, we can store the said file (or its binary data) in the Database
	- MongoDB and SQL supports storing binary data through Buffer and BLOB respectively

GOAL:
1. Store the user profile image binary data in the User Document in the "avatar" field

EX:
// Multer instance config, see that "dest" is NOT defined
const upload = multer({
  limits: {
    fileSize: 1000000,
  },
  fileFilter(req, file, cb) {
    if (!file.originalname.match(/\.(jpg|jpeg|png)/)) {
      cb(new Error("Please upload only jpg, jpeg, and png files only"));
    }

    cb(null, true);
  },
});

// Route for handling upload user profile
router.post(
  "/users/me/avatar",
  auth,
  upload.single("avatar"),
  async (req, res) => {
    req.user.avatar = req.file.buffer;
    await req.user.save();
    res.send();
  },
  (error, req, res, next) => {
    res.status(400).send({ error: error.message });
  }
);

// for deleting avatar Field
router.delete(
  "/users/me/avatar",
  auth,
  async (req, res) => {
    await User.updateOne(
      { _id: req.user._id },
      {
        $unset: {
          avatar: "",
        },
      }
    );
    res.send();
  },
  (error, req, res, next) => {
    res.status(400).send({ error: error.message });
  }
);


NOTE:
1. Setting a field to "undefined" will REMOVE the said Field to the Document
	- different from setting it to "null" where the Field in Document STAYS but with value of null









128 Serving up Files

Function/Objects used
res.set(headerName: string, value: any)
 > function of response to set a header with specified value
 > if header doesnt exist, will create NEW header

"Content-Type"
 > special header of the response
 > almost all response have this header
 > defines the data response contains
 > the value of this header includes the MIME types
	- this will also change how the browser will interact with the data
 > the following values that can be assigned includes but not limited to
	1. audio/wav
	2. image/jpg
	3. text/html
	4. application/json


Serving up Files
 > with Express, we can configure how we serve up data/files
 > we can do this by setting the "Content-Type" header of response to the specific MIME types that we want

EX:
router.get("/users/:id/avatar", async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user?.avatar) {
      throw new Error();
    }
    res.set("Content-Type", "image/jpg");
    res.send(user.avatar);
  } catch (e) {
    res.send(404).send();
  }
});









129 Auto-Cropping and Image Formatting

Auto-Cropping and Image Formatting
 > right now, we have doing validation to file uploads where we will only accept files of less than 1mb
 > this is fine, but sometimes for specific use cases like image profile, we want to control the images being uploaded/added using its properties like
	- size
	- ratio
	- color
 > with this, we can use npm module to do this things, like the "sharp" module


sharp
 > The typical use case for this high speed Node.js module is to convert large images in common formats to smaller, web-friendly JPEG, PNG, WebP, GIF and AVIF images of varying dimensions.
 > to install sharp, use the command
	- npm i sharp
 > with this module, we can do things in the images like resizing, reformatting to another image formats, etc


sharp module Functions/Objects

sharp(input?: Buffer | string): Sharp
 > used to create an instance of a Sharp
 > takes either the Buffer of image, or the string equivalent of the Buffer bytes
 > starting point when using the sharp module

Sharp.sharp(options?: SharpOptions): Sharp
 > another overload of sharp() function
 > takes options object which is used to modify the Sharp instance, which then modifies the image it hold
 > we can define the properties of this options object which includes
	1. width: number
		- width of resulting image by pixels
	2. height: number
		- height of resulting image by pixels

Sharp.png(): Sharp
 > convert the image inside the Sharp instance to .png format

Sharp.toBuffer(): Promise<Buffer>
 > convert the modified image inside Sharp instance into the buffer
 > returns a Promise which contains the buffer



EX:
// Route for uploading user
router.post(
  "/users/me/avatar",
  auth,
  upload.single("avatar"),
  async (req, res) => {
    const buffer = await sharp(req.file.buffer)
      .resize({ width: 250, height: 250 })
      .png()
      .toBuffer();
    req.user.avatar = buffer;
    await req.user.save();
    res.send();
  },
  (error, req, res, next) => {
    res.status(400).send({ error: error.message });
  }
);

