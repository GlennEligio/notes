10 Modules and Namespaces

Contents
140 Module Introduction
141 Writing Module Code - Your Options
142 Working with Namespaces
143 Organizing Files & Folders
144 A Problem with Namespace Imports
145 Important Use of Chrome or Firefox
146 Using ES Modules
147 Understanding various Import & Export Syntaxes
148 How Does Code in Modules Execute
149 Wrap Up
150 Useful Resources & Links










140 Module Introduction

Module Content:
1. Two Options to Organize Code in Multiple Files
2. Demo Time!











141 Writing Module Code - Your Options

Splitting Code Into Multiple Files 
 > for this method, we have two options
   1. Namespaces & File Bundling
   2. ES6 Imports/Exports
   3. Create multiple .ts file, and manually import compiled .js file into HTML
	> cumbersome and error prone

Namespaces & File Bundling
 > Uses "namespace" code syntax to group code
 	- namespaces is a TypeScript syntax feature and we need to use special code to use this feature
 	- allows us to GROUP code together (similar to package in Java)
 	- we can then IMPORT these namespaces to other files in order to use the codes inside the said namespace\
 > Per-file or bundled compilation is possible (less imports to manage)
	
ES6 Imports/Exports (or ES6 modules)
 > modern alternative
 > uses the ES6 import/export syntax
 > per-file compilation but single <script> import
 > File-bundling via third-party tools (e.g. Webpack) is possible









142 Working with Namespaces

Working with Namespace
 > namespaces are EXCLUSIVE to TypeScript, not available to JavaScript
 > TypeScript doesnt have direct translation of namespace in JavaScript


Creating a namespace
 > to create a namespace, we will use the following syntax:

SYNTAX:
namespace SomeNamespaceName {
  // codes to group up
}

EX:
// Drag & Drop interfaces
namespace DDInterfaces {
  interface Draggable {
    dragStartHandler(event: DragEvent): void;
    dragEndHandler(event: DragEvent): void;
  }

  interface DragTarget {
    dragOverHandler(event: DragEvent): void;
    dropHandler(event: DragEvent): void;
    dragLeaveHandler(event: DragEvent): void;
  }
}


Using Code (Function/Class/Interface/Objects) from a namespace
 > we can ONLY access function/class/interface/object from the SAME namespace
	- this means that in order for a function to use a code inside a specific namespace, they MUST RESIDE IN THE SAME namespace
 > to access code of same namespace BUT different file, we need to make sure that 
	1. The file origin of the code that we are fetching is "imported"
		- TypeScript have a special syntax for importing code from other files
	2. The code is be fetched is EXPORTED inside the namespace
		- if not, other files will NOT be able to access them

SYNTAX: TypeScript "import"
 > start with triple slash (///)
 > create a markup element "reference" with a "path" property
	- the path property must point to the path directory of the file to import

EX:
/// <reference path="drag-drop-interfaces.ts"/>



EX: Using TypeScript import to use code from same namespace but different file location
// drag-drop.interface.ts
namespace App {
  export interface Draggable {
    dragStartHandler(event: DragEvent): void;
    dragEndHandler(event: DragEvent): void;
  }

  export interface DragTarget {
    dragOverHandler(event: DragEvent): void;
    dropHandler(event: DragEvent): void;
    dragLeaveHandler(event: DragEvent): void;
  }
}

// inside app.ts
/// <reference path="drag-drop-interface.ts" />

namespace App {
  class ProjectItem
    extends Component<HTMLUListElement, HTMLLIElement>
    implements Draggable
  { ... }

  class ProjectList
    extends Component<HTMLDivElement, HTMLFormElement>
    implements DragTarget
  { ... }
}


Problem with namespaces and <reference> method
 > like said earlier, namespace in TypeScript have NO EQUIVALENT in JavaScript
 	- with <reference> imports and namespaces, we can easily tell the TypeScript where to look for the specific code we need
	- but after being compiled in JavaScript, these connections is destroyed since namespaces and <reference> doesnt exist in JavaScript
		-> all the compiled .js file generated by separate .ts files does not know how to link each other
 > to fix this connection issue, we can setup TypeScript to CONCATENATE the .js file outputs of .ts file compilation into a SINGLE FILE
	- with this, the compiled .js file can easily find their "dependencies" since they are just in ONE JAVASCRIPT FILE


Configuring TypeScript to bundle compiled .js file into ONE FILE
1. In tsconfig.json, set the following compilerOptions properties
	> outFile
		- if defined, tell TypeScript to concatenate and emit output to single file
		- pass the directory of the bundled .js file
		- ex: "outFile": "./dist/bundl.js"
 	> module
		- Specify module code generation
		- set it to either "amd" or "system"
		- this is because they are the only module that can load/bundle multiple .js files into one
		- ex: "module": "amd"


Using the bundled .js file in HTML file
 > using the bundled .js file is THE SAME as using any .js file, through the <script> element in head
	- add "defer" property to <script> will tell browser to execute the script after rendering the page


Project Structure with bundled .js file
> root
  > dist
    - bundle.js
    - bundle.js.map
  > src
    - app.ts
    - drag-drop-interface.ts
    - project-model.ts
  - index.html
  - tsconfig.json











143 Organizing Files & Folders

Final "src" folder structure
src
│   app.ts
│
├───components
│       base-component.ts
│       project-input.ts
│       project-item.ts
│       project-list.ts
│
├───decorators
│       autobind.ts
│
├───models
│       drag-drop.ts
│       project.ts
│
├───state
│       project-state.ts
│
└───util
        validation.ts


NOTE:
1. ProjectItem, ProjectInput, and ProjectList have dependency to Component, therefore their .ts file must have reference to the .ts file that contains Component abstract class








144 A Problem with Namespace Imports

Problem with Namespace Imports
 > each of the .ts file must import their necessary "code" by using <reference> from TypeScript
 > right now, we are just importing all the .ts files in the app.ts
	- the problem in the setup is we might load a specific .ts file BEFORE the .ts file that it depends on

Ex:
In setup below, we loaded the autobind.ts before any of the component .ts files which depends on the autobind.ts.
If we load the components .ts files FIRST before the autobind.ts, this will cause an error since by the time we load the components .ts file, autobind.ts codes DOESNT EXIST. 
	- this will most likely cause an error related to undefined reference

/// <reference path="./models/drag-drop.ts" />
/// <reference path="./models/project.ts" />
/// <reference path="./state/project-state.ts"/>
/// <reference path="./util/validation.ts"/>
/// <reference path="./decorators/autobind.ts"/>
/// <reference path="./components/base-component.ts"/>
/// <reference path="./components/project-item.ts"/>
/// <reference path="./components/project-list.ts"/>
/// <reference path="./components/project-input.ts"/>

namespace App {
  new ProjectInput();
  new ProjectList("active");
  new ProjectList("finished");
}


Solution
 > manually defined all the <reference/> or dependencies a .ts file needs


EX:
// project-item.ts
/// <reference path="base-component.ts"/>
/// <reference path="../models/drag-drop.ts"/>
/// <reference path="../models/project.ts"/>
/// <reference path="../decorators/autobind.ts"/>

// project-list.ts
/// <reference path="base-component.ts"/>
/// <reference path="../models/drag-drop.ts"/>
/// <reference path="../models/project.ts"/>
/// <reference path="../decorators/autobind.ts"/>
/// <reference path="../state/project-state.ts"/>

// project-input.ts
/// <reference path="base-component.ts"/>
/// <reference path="../decorators/autobind.ts"/>
/// <reference path="../state/project-state.ts"/>
/// <reference path="../models/drag-drop.ts"/>
/// <reference path="../models/project.ts"/>
/// <reference path="../util/validation.ts"/>

// app.ts
/// <reference path="./components/project-list.ts"/>
/// <reference path="./components/project-input.ts"/>









145 Important Use of Chrome or Firefox

NOTE:
Later sections will only work in modern browsers






146 Using ES Modules

Function/Object used
import
 > used to import specific objects/functions from a JavaScript file
 > we can either import default exports or named exports from a JS file

"import" SYNTAX:
import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { default as alias } from "module-name";
import { export1 , export2 } from "module-name";
import { export1 , export2 as alias2 , [...] } from "module-name";
import { "string name" as alias } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";



ES6 Modules
 > JavaScript modules that is natively support in browsers that support ES6 (ES2015)
 > dependent on the "import" and "export" statements, which are supported by browser with ES6 compatibility as well

TypeScript and ES6 modules
 > right now, we are using the "namespace" and "reference" in order to import necessary code from one file to another
 > but with this, we will NOT have the TYPE SUPPORT that we want in TypeScript	
	- ex: if we dont import necessary typescript file, TypeScript will not detect this in compilation but it will cause error in the compiled JS files
 > with ES6 Modules, we will abandon the "namespace" and "reference", and instead use the "import" and "export"
	- with this, we will have access to the type support which is the main reason why we are using TypeScript

Requirement for ES6 module support in TypeScript
1. Remove the namespace and reference statements
2. Change the "module" in tsconfig.json to 'es2015'
	> this will make the "import" and "export" statement be preserved in the compiled JS file
3. Make sure the 'target' is 'es6'
4. Make sure 'outFile' is NOT DEFINED
	> to prevent the bundled js file, since we need to compile the .ts file into separate .js file
5. "import" must be importing .js file and not .ts file
6. In the browser that will use the compiled .js file, add "type" to the <script> and pass "module"	
	> we can now also remove the "defer" property

Checking if ES6 module is working
 > Inspect the page
 > Check the network, you must see that we are fetching individual .js files that are needed at the moment


NOTE:
1. Make sure we are importing from the compiled .js file and not from .ts file

EX:
import { Component } from "./base-component.js";
import { Validatable, validate } from "../util/validation.js";
import { Autobind } from "../decorators/autobind.js";
import { projectState } from "../state/project-state.js";












147 Understanding various Import & Export Syntaxes

Import SYNTAX
 > defaultExport refers to the default export of the module
 > * will import ALL named exports in the module
	- typically used with "as" keyword to give it an alias
 > all named export MUST be included inside the curly braces to be imported
 > default export MUST NOT be included inside the curly braces to be imported
 > "as" keyword is used 

import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { default as alias } from "module-name";
import { export1 , export2 } from "module-name";
import { export1 , export2 as alias2 , [...] } from "module-name";
import { "string name" as alias } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";



Export SYNTAX:

// Exporting individual features
export let name1, name2, …, nameN; // also var, const
export let name1 = …, name2 = …, …, nameN; // also var, const
export function functionName(){...}
export class ClassName {...}

// Export list
export { name1, name2, …, nameN };

// Renaming exports
export { variable1 as name1, variable2 as name2, …, nameN };
export { variable1 as "string name" };

// Exporting destructured assignments with renaming
export const { name1, name2: bar } = o;
export const [ name1, name2 ] = array;

// Default exports
export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*
export { name1 as default, … };

// Aggregating modules
export * from …; // does not set the default export
export * as name1 from …; // ECMAScript® 2020
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;
export { default, … } from …;












148 How Does Code in Modules Execute

NOTE:
1. Modules are only executed ONCE regardless on how many we import it
	> even if we import the said module in different files, it will still be executed ONCE










149 Wrap Up

NOTE:
1. Use ES6 modules rather than namespace and reference since it gives us type support.

150 Useful Resources & Links
