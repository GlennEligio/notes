DAY 2 Spring

~~~~~ AOP ~~~~~~

AOP 
	> Aspect oriented programming
	> Aspects (Concerns) are general issues of development 
	> Separation of Concern

Concerns 
	> Non-functional feature are example of Concerns
	> ex: Filters in JSP, Servlet which will take care 
		- logging	
		- internalisation 
		- transactions
		- security
		- events


Non functional features
	> features that are NOT NEEDED to make a system functional
	> these features can be added and remove to system without affect the whole function of system
	> these features will NOT AFFECT other features
	> user are NOT AWARE of these features if they are not present

~~~~ HIBERNATE ~~~~

ORM
	> object relationship mapping

JDBC
	> table centric approach

Hibernate
	> ORM tool
	> no need to write to queries
	> will take care of query to send to SQL


Transaction of Client to Db
Client  ->  ORM	-> JDBC -> DB

SessionFactory
	> factory class for Session
	> Session are created based on the config file presented to them

config file
	> contains all information about DB like
		- DB URL (IP ADDRESS, TCP PORT), USER, PASS

Session	
	> represents a Connection of Client to DB
	> private and only visible to its own Client


Cache
	> stores data temporarily
	> two levels
		1st level (session level)
		2nd level (sessionFactory level)
	> when we send a query for the first time, it will store the result in both Session and SessionFactory as cache
	> when we send the same query for the second time, it will not send a SQL query to database. INSTEAD it will just fetch the cached result in Session, or SessionFactory
	> we can observe this by looking at console
		1. Make sure we have this element inside <session-factory> of hibernate.cfg.xml
			> with this, the SQL queries SessionFactory send to DB will be printed in Console

			        <property name="show_sql">true</property>
		
		2. Send a query where we fetch a specific data, then print the result
		3. Send the same query again and print the result again

				Address add = (Address) session.get(Address.class, 1);
				System.out.println(add.getCity());
				Address add2 = (Address) session.get(Address.class, 1);
				System.out.println(add2.getCity());
		
		4. Observe the output
			> we can see that the SQL query is only printed once

				Hibernate: select address0_.aid as aid1_0_, address0_.city as city1_0_, address0_.state as state1_0_ from addresses address0_ where address0_.aid=?
				Manila
				Manila

ANNOTATIONS - AOP

@Aspect
	> added in a @Component Class
	> defines that the @Component is an Aspect

@Before(value = "execution(return-type fully-classified-method-package-location(parameter-type))")
	> added in a method inside @Aspect Class
	> this will execute the @Aspect's method BEFORE the method specified in value parameter
	> SYNTAX of value="String"

		@Before(value = "execution(* com.app.WelcomeImpl.sayHi(..))")

		execution
			> means that method will RUN BEFORE EXECUTION of method passed
		*
			> means that it will run on the method passed REGARDLESS OF RETURN TYPE
			> * is a UNIVERSAL SELECTOR
		com.app.WelcomeImpl.sayHi()
			> fully classified package location name of the method that we will watch
			> means that before the sayHi() of WelcomeImpl class is executed, the @Before method will run first
		..
			> means that it will run on the method passed REGARDLESS of the parameters passed

@After(value = "execution(return-type fully-classified-method-package-location(parameter-type))")
	> same as the @Before
	> the method of @Aspect will run AFTER the method passed in value is executed

@Around(value = "execution(return-type fully-classified-method-package-location(parameter-type))")
	> same as the @Before and @Aspect
	> the method of @Aspect will run BEFORE AND AFTER the method passed in value is executed
	> inside the method, we will need to write "two" method and will be SEPARATED by proceed() of ProceedingJoinPoint parameter
	> this proceed() will stop the method from running until the method is done executing

@AfterReturning(value = "execution(return-type fully-classified-method-package-location(parameter-type))", returning="data-type")
	> same as @After except it will be called after the method passed RETURNS a value
	> we also need to specify the return type by adding returning parameter to @AfterReturning



ANNOTATIONS - Hibernate

@Entity	
	> added in a Class (POJO)
	> the Hibernate will create a table using the Class and its properties as column
@Table(name="table-name")
	> added in an @Entity class
	> modifies the generated table for @Entity
	> have the following parameters
		a. table="table-name"
			- changes the table name that Hibernate generates
@Id
	> added in one of @Entity property
	> marks the said property as the primary key of the table generated
	> preferrable a type that can be incremented (int)
@GeneratedValue
	> added in the @Id property
	> make the 
@OneToOne()
	> Defines a single-valued association to another entity that has one-to-one multiplicity.
	> have several parameters which includes:
		a. cascade=CascadeType[]
		b. fetch=FetchType[]
@OneToMany()
	> Defines a many-valued association with one-to-many multiplicity.
	> have several parameters which includes:
		a. cascade=CascadeType[]
		b. fetch=FetchType[]
	
CascadeType 
	> Enum that defines the set of cascadable/passable operations that are propagated to the associated entity. 
		- ex: updating foreign key of mapper table will update the key assiociated with it in mapped table
	> The value cascade=ALL is equivalent to cascade={PERSIST, MERGE, REMOVE, REFRESH, DETACH}.
	> the values of this Enum includes:
		1. ALL
			Cascade all operations
		2. DETACH
			Cascade detach operation
		3. MERGE
			Cascade merge operation
		4. PERSIST
			Cascade persist operation
		5. REFRESH
			Cascade refresh operation
		6. REMOVE
			Cascade remove operation

FetchType[]
	> Enum that defines strategies for fetching data from the database.
	> The EAGER strategy is a requirement on the persistence provider runtime that data must be eagerly fetched. 
	> The LAZY strategy is a hint to the persistence provider runtime that data should be fetched lazily when it is first accessed. 
	> The implementation is permitted to eagerly fetch data for which the LAZY strategy hint has been specified.
	> FetchType enum values include
		1. FetchType.LAZY
			- Defines that data can be lazily fetched.
		2. FetchType.EAGER
			- Defines that data can be eagerly fetched


CLASSES - AOP

JoinPoint
	> Provides reflective access to both the state available at a join point and static information about it.
	> This information is available from the body of advice using the special form thisJoinPoint.  
	> The primary use of this reflective information is for tracing and logging applications.
	> method of JoinPoint are

Signature getSignature()
	> returns the signature of the method we passed which includes
		- return type
		- method name
		- parameters


ProceedingJoinPoint
	> usable only in @Around
	> ProceedingJoinPoint exposes the proceed(..) method in order to support around advice in @AJ aspects
	> represents the multiple JoinPoints in the @Around since @Around is @Before + @After combined
	> to get the JoinPoint in @After, we will call proceed() of ProceedingJoinPoint



CLASSES - Hibernate

SessionFactory
	> used to create Session instances
	> The main contract here is the creation of Session instances. 
	> Usually an application has a SINGLE SessionFactory instance and threads servicing client requests obtain Session instances from this factory.
	> The internal state of a SessionFactory is immutable. Once it is created this internal state is set. This internal state includes all of the metadata about Object/Relational Mapping.
	> Implementors must be THREADSAFE
	> to build a SessionFactory, we will use the output of the method call below

		new AnnotationConfiguration().configure().buildSessionFactory()


Session
	> represents a Session of Client to DB
	> The main runtime interface between a Java application and Hibernate. This is the central API class abstracting the notion of a persistence service.
	> The lifecycle of a Session is bounded by the beginning and end of a logical transaction. (Long transactions might span several database transactions.)
	> The main function of the Session is to offer CREATE, READ, AND DELETE operations for instances of mapped entity classes. 	> Instances may exist in one of three states:
		1. transient: never persistent, not associated with any Session
		2. persistent: associated with a unique Session
		3. detached: previously persistent, not associated with any Session
	> Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete(). Any instance returned by a get() or load() method is persistent. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge().
	> save() and persist() result in an SQL INSERT, delete() in an SQL DELETE and update() or merge() in an SQL UPDATE. Changes to persistent instances are detected at flush time and also result in an SQL UPDATE. saveOrUpdate() and replicate() result in either an INSERT or an UPDATE.

METHODS of Session object

Serializable save(Object entity)
	> used to "save" and add the Entity object that we passed to it in the database
	> must call commit() of Transaction object to apply changes to database
Query createQuery("from table-name")
	> creates a Query object whose target table is the String passed on createQuery()
	> used for fetching List of Rows in the table
Object get(Class type, Serializable id)
	> used to get a specific Object of Class type whose properties is the value of the row whose primary key is the Serialize id that we passed
void update(Object entity)
	> used to update a specific row whose primary key corresponds to @Id field member of Object passed
	> must call commit() of Transaction object to apply changes to database
void delete(Object entity)
	> used to delete a specific row whose primary key corresponds to @Id field member of Object passed
	> must call commit() of Transaction object to apply changes to database



Query
	> An object-oriented representation of a Hibernate query. 
	> A Query instance is obtained by calling 

		Session.createQuery().

	> Queries are executed by calling 
		- list()
			> returns a List of Object based on the ResultSet we got
		- scroll() or 
		- iterate()
	> A query may be re-executed by subsequent invocations. Its lifespan is, however, bounded by the lifespan of the Session that created it.




Transaction
	> represents a Transaction to the database
	> typically used when using DML queries in database (CREATE, UPDATE, DELETE)
	> Allows the application to define units of work, while maintaining abstraction from the underlying transaction implementation (eg. JTA, JDBC).
	> A transaction is associated with a Session
	> usually instantiated by a call to 

		Session.beginTransaction().

	> method of Transactions include:

commit()
	> save the changes made by CREATE, UPDATE, DELETE operation of Session





