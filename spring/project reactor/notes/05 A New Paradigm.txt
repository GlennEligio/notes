05 A New Paradigm

New Code with Reacting Programming

@GetMapping("/users/{userId}")
public Mono<User> getUserDetails(@PathVariable String userId) {
	return userService.getUser(userId)		.zipWith(userPreferencesService.getPreferences(userId))
	.map(tuple -> {
		User user = tuple.getT1();
		user.setUserPreferences(tuple.getT2());
		return user;
	})
}


1. Get the User object using getUser()
2. Zip it with the UserPreferences object result from getPreferences()
	> this results in a Tuple (array with two objects, term from TypeScript)
3. We will the use the map() function to transform this Tuple object into a User, by fetching the User and UserPreferences object from it


What different in Reactive programming
1. Much simple than the manual concurrent way
2. Few reusable flexible functions
3. Combine and reuse these functions in powerful ways



Reactive Programming
 > Declarative code to build asynchronous processing pipelines
 > with this, theres different ways of thinking about 'flow' and 'data'
 > Integrated with Java 'Flow' interface
	- we dont use the Flow interface directly


NOTES:
1. For smaller projects, it not worth it to use reactive programming