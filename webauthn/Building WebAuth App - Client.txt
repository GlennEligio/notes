Building WebAuthn app - Client side

SOURCE:
https://developers.google.com/codelabs/webauthn-reauth#0

CONTENTS:
I. Before you being
II. Get set up
III. Register a credential with a fingerprint
IV. Build the UI to register, get, and remove credentials
V. Authenticate the user with a fingerprint
VI. Enable reauthentication experience
VII. Final 







I. Before you being

WebAuthn
 > stands for Web Authentication API
 > lets us create and use origin-scoped, public-key credentials to authenticate users
 > the API supports the use of 
	1. Roaming authenticators like BLE, NFC, and USB-roaming U2F or FIDO2 authenticators - also known as security - 
	2. Platform authenticator, which lets users authenticate with their fingerprints or screen locks

Prerequisites
1. Basic understanding of how WebAuthn works
2. Basic programming skills with JavaScript

What you'll do
 > Build a website with a simple reauthentication functionality that uses a fingerprint sensor

What you'll need
1. One of the following devices:
	- An Android device, preferably with a biometric sensor
	- An iPhone or iPad with Touch ID or Face ID on iOS 14 or higher
	- A MacBook Pro or Air with Touch ID on macOS Big Sur or higher
	- Windows 10 19H1 or higher with Windows Hello set up
2. One of the following browsers:
	- Google Chrome 67 or higher
	- Microsoft Edge 85 or higher
	- Safari 14 or higher










II. Get set up

https://developers.google.com/codelabs/webauthn-reauth#1









III. Register a credential with a fingerprint
GOAL: Register a credential using a fingerprint
STEPS:
1. Create `registerCredential()` function
2. Obtain the challenge and other options from server endpoint: `/auth/registerRequest`
3. Create a credential
4. Register the credential to the server endpoint: `/auth/registerResponse`


Registering a credentials with a fingerprint
 > we need to register a credentials generated by a User Verifying Platform Authenticator (UVPA)
	- UVPA refers to the built in authenticator in the device and verifies the user's identity
 > UVPA is typically seen as fingerprint sensor depending on the user's device


1. Create registerCredential() function
 > this function will register a new credentials to the WebAuthn server
 > this essentially sends an HTTP request that contains the following JSON object as body
	- this represents the options that will be used to create the CHALLENGE

// inside registerCredential() function
export const registerCredential = async () => {
	const opts = {
	  attestation: 'none',
	  authenticatorSelection: {
	    authenticatorAttachment: 'platform',
	    userVerification: 'required',
	    requireResidentKey: false
	  }
	};

	const options = await _fetch('/auth/registerRequest', opts);
};


Sending data to the WebAuthn Server
 > The protocol between a server and a client is NOT a part of the WebAuthn specification.
 > However, this codelab is designed to align with the WebAuthn specification and the JSON object that we pass to the server is VERY SIMILAR to the "PublicKeyCredentialCreationOptions" so that it's intuitive for us.
 > The information below contains the important parameters that we can pass to the server and explains what they do:

Parameters and their Descriptions 
 > for more information, go to "https://www.w3.org/TR/webauthn/#dictdef-publickeycredentialcreationoptions"
1. attestation
 	> Preference for attestation conveyanceâ€”none, indirect, or direct. 
 	> Choose none unless you need one.
2. excludeCredentials
 	> Array of PublicKeyCredentialDescriptor so that the authenticator can avoid creating duplicate ones.
3. authenticatorSelection.authenticatorAttachment
 	> Filter available authenticators. 
	> If you want an authenticator attached to the device, use "platform". 
	> For roaming authenticators, use "cross-platform".
4. authenticatorSelection.userVerification
 	> Determine whether authenticator local user verification is "required", "preferred", or "discouraged". 
	> If you want fingerprint or screen-lock authentication, use "required".
5. authenticatorSelection.requireResidentKey
 	> Use true if the created credential should be available for future account picker UX.

Obtaining the Challenge
 > if the HTTP request that we sent to send WebAuthn Server the "PublicKeyCredentialCreationOptions", we should receive a JSON file the contains several properties.
	- This includes the "challenge" and "user.id" properties which we will use to create Credential

EX:
// response JSON after sending PublicKeyCredentialCreationOptions
{
  "rp": {
    "name": "WebAuthn Codelab",
    "id": "webauthn-codelab.glitch.me"
  },
  "user": {
    "displayName": "qweqwe",
    "id": "wBjzbTJ_lRb26Pwb7qdYoVs-NzpiCo6rV-Yr3sEbdDY",
    "name": "qweqwe"
  },
  "challenge": "G9rZZzYw6ZKEjSwIvITYPlqyWRKYy1I3HN-jYAS0RzQ",
  "pubKeyCredParams": [
    {
      "type": "public-key",
      "alg": -7
    }, {
      "type": "public-key",
      "alg": -257
    }
  ],
  "timeout": 1800000,
  "attestation": "none",
  "excludeCredentials": [
    {
      "id": "...",
      "type": "public-key",
      "transports": [
        "internal"
      ]
    }
  ],
  "authenticatorSelection": {
    "authenticatorAttachment": "platform",
    "userVerification": "required"
  }
}


Creating a Credential
1. because these options are delivered encoded to go through HTTP protocol, convert some parameters back to binary, specifically the
	1. user.id
	2. challenge
	3. instances of "id" included in the "excludeCredentials" array
 > Note: You see an error message that says 'base64url' is not defined. with red dots on Glitch.com UI, but you can ignore it.

// inside registerCredential(), after getting response from fetch()
options.user.id = base64url.decode(options.user.id);
options.challenge = base64url.decode(options.challenge);

if (options.excludeCredentials) {
  for (let cred of options.excludeCredentials) {
    cred.id = base64url.decode(cred.id);
  }
}

2. Call the navigator.credentials.create() method to create a new credential
	> With this call, the browser interacts with the authenticator and tries to verify the user's identity with the UVPA.

// inside public/client.js registerCredential() function, after decoding the some properties of option variable
const cred = await navigator.credentials.create({
  publicKey: options,
});


3. Register the credential to the server endpoint


// FINAL CODE for registerCredential() function

// TODO (1): Register a credential using a fingerprint
// 1. Create `registerCredential()` function
// 2. Obtain the challenge and other options from server endpoint: `/auth/registerRequest`
// 3. Create a credential
// 4. Register the credential to the server endpoint: `/auth/registerResponse`

export const registerCredential = async () => {
  // create options to send to server for challenge
  const opts = {
    attestation: "none",
    authenticatorSelection: {
      authenticatorAttachment: "platform",
      userVerification: "required",
      requireResidentKey: false,
    },
  };

  // send options to endpoint and await for challenge response
  const options = await _fetch("/auth/registerRequest", opts);
  
  // decode the user.id, challenge, and all cred.id inside excludeCredentials of challenge response to base64
  options.user.id = base64url.decode(options.user.id);
  options.challenge = base64url.decode(options.challenge);

  if (options.excludeCredentials) {
    for (let cred of options.excludeCredentials) {
      cred.id = base64url.decode(cred.id);
    }
  }

  // create credentials using navigator.credentials.create()
  const cred = await navigator.credentials.create({
    publicKey: options,
  });

  // create empty object to hold credentials properties 
  // this will serve as a placeholder
  // here we will encode the rawId using base64
  const credential = {};
  credential.id = cred.id;
  credential.rawId = base64url.encode(cred.rawId);
  credential.type = cred.type;

  // check if response property exist in credentials
  // if it does, base64 encode both the clientDataJSON and attestationObject of credentials, then assign them to the placeholder object earlier
  if (cred.response) {
    const clientDataJSON = base64url.encode(cred.response.clientDataJSON);
    const attestationObject = base64url.encode(cred.response.attestationObject);
    credential.response = {
      clientDataJSON,
      attestationObject,
    };
  }

  // store the credential id in localStorage for re authentication
  localStorage.setItem(`credId`, credential.id);

  // send the created credentials to server for registering
  return await _fetch("/auth/registerResponse", credential);
};














IV. Build the UI to register, get, and remove credentials
GOAL: Build the UI to register, get and remove credentials
1. Build UI placeholder	
	> Add UI to list credentials and a button to register a new credential. 
	> Depending on whether the feature is available or not, you remove the hidden class from either the warning message or the button to register a new credential. 
	> ul#list is the placeholder for adding a list of registered credentials.
2. Feature detection and UVPA availability
	> Follow these steps to check the UVPA availability:
		- Examine window.PublicKeyCredential to check if WebAuthn is available.
		- Call PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() to check if a UVPA is available . 
			-> If they're available, you show the button to register a new credential. 
			-> If either of them are not available, you show the warning message.
3. Remove the credential: `removeCredential()`
	> In the list of credentials, you added a button to remove each credential. You can send a request to /auth/removeKey along with the credId query parameter to remove them.
	> Append unregisterCredential to the existing import statement.
4. Register a credential
	> You can call registerCredential() to register a new credential when the user clicks Add a credential.
	> Append registerCredential to the existing import statement.
	> Invoke registerCredential() with options for navigator.credentials.create().
	> Don't forget to renew the credential list by calling getCredentials() after registration.
5. Get a list of credentials and display: `getCredentials()`
	> vies/home.html script



// UI for Adding Authentication
// in script below, we will add functionality where we will show the button ONLY if we have the feature

      <p id="uvpa_unavailable" class="hidden">
        This device does not support User Verifying Platform Authenticator. You
        can't register a credential.
      </p>
      <h3 class="mdc-typography mdc-typography--headline6">
        Your registered credentials:
      </h3>
      <section>
        <div id="list"></div>
      </section>
      <mwc-button id="register" class="hidden" icon="fingerprint" raised
        >Add a credential</mwc-button
      >
      <mwc-button raised><a href="/reauth">Try reauth</a></mwc-button>
      <mwc-button><a href="/auth/signout">Sign out</a></mwc-button>



// JS code for Feature detection and UVPA availability
      // Check if PublicKeyCredential feature exist in browser and UVPA is available
      if (window.PublicKeyCredential) {
        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(
          (uvpaa) => {
            if (uvpaa) {
              // shows the register button
              register.classList.remove("hidden");
            } else {
              // show the prompt about uvpa unavailability
              document
                .querySelector("#uvpa_unavailable")
                .classList.remove("hidden");
            }
          }
        );
      } else {
        // show the prompt about uvpa unavailability
        document.querySelector("#uvpa_unavailable").classList.remove("hidden");
      }


// JS code for fetching credentials in Server and displaying them
      // Get list of Credentials in the Server
      // for each Credentials, display the credential id and public key associated to it
      const getCredentials = async () => {
        const res = await _fetch("/auth/getKeys");
        const list = document.querySelector("#list");
        const creds = html`${res.credentials.length > 0
          ? res.credentials.map(
              (cred) => html` <div class="mdc-card credential">
                <span class="mdc-typography mdc-typography--body2"
                  >${cred.credId}</span
                >
                <pre class="public-key">${cred.publicKey}</pre>
                <div class="mdc-card__actions">
                  <mwc-button
                    id="${cred.credId}"
                    @click="${removeCredential}"
                    raised
                    >Remove</mwc-button
                  >
                </div>
              </div>`
            )
          : html` <p>No credentials found.</p> `}`;
        render(creds, list);
      };


// JS code removing credentials in the list that is assigned for the click eventListener of credential list item
      // calls unregisterCredential to unregister credentials, then updates the credentials list
      const removeCredential = async (e) => {
        try {
          await unregisterCredential(e.target.id);
          getCredentials();
        } catch (e) {
          alert(e);
        }
      };


// JS code for click eventListener of register credential button
      // click eventListener of "Add Authentication" button
      register.addEventListener("click", (e) => {
        registerCredential()
          .then((user) => {
            getCredentials();
          })
          .catch((e) => alert(e));
      });




// FINAL CODE
// views/home.html
...
      <p id="uvpa_unavailable" class="hidden">
        This device does not support User Verifying Platform Authenticator. You can't register a credential.
      </p>
      <h3 class="mdc-typography mdc-typography--headline6">
        Your registered credentials:
      </h3>
      <section>
        <div id="list"></div>
        <mwc-fab id="register" class="hidden" icon="add"></mwc-fab>
      </section>
      <mwc-button raised><a href="/reauth">Try reauth</a></mwc-button>
      <mwc-button><a href="/auth/signout">Sign out</a></mwc-button>
    </main>
    <script type="module">
      import { _fetch, registerCredential, unregisterCredential } from '/client.js';
      import { html, render } from 'https://unpkg.com/lit-html@1.0.0/lit-html.js?module';

      const register = document.querySelector('#register');

      if (window.PublicKeyCredential) {
        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
        .then(uvpaa => {
          if (uvpaa) {
            register.classList.remove('hidden');
          } else {
            document
              .querySelector('#uvpa_unavailable')
              .classList.remove('hidden');
          }
        });        
      } else {
        document
          .querySelector('#uvpa_unavailable')
          .classList.remove('hidden');
      }

      const getCredentials = async () => {
        const res = await _fetch('/auth/getKeys');
        const list = document.querySelector('#list');
        const creds = html`${res.credentials.length > 0 ? res.credentials.map(cred => html`
          <div class="mdc-card credential">
            <span class="mdc-typography mdc-typography--body2">${cred.credId}</span>
            <pre class="public-key">${cred.publicKey}</pre>
            <div class="mdc-card__actions">
              <mwc-button id="${cred.credId}" @click="${removeCredential}" raised>Remove</mwc-button>
            </div>
          </div>`) : html`
          <p>No credentials found.</p>
          `}`;
        render(creds, list);
      };

      getCredentials();

      const removeCredential = async e => {
        try {
          await unregisterCredential(e.target.id);
          getCredentials();
        } catch (e) {
          alert(e);
        }
      };

      register.addEventListener('click', e => {
        registerCredential({
          attestation: 'none',
          authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            requireResidentKey: false
          }
        })
        .then(user => {
          getCredentials();
        })
        .catch(e => alert(e));
      });
    </script>
...


// public/client.js
...
export const unregisterCredential = async (credId) => {
  localStorage.removeItem('credId');
  return _fetch(`/auth/removeKey?credId=${encodeURIComponent(credId)}`);
};
...













V. Authenticate the user with a fingerprint

Authenticate the user with a fingerprint
 > You now have a credential registered and ready to use as a way to authenticate the user. Now you add reauthentication functionality to the website. Here's the user experience:
 > When a user lands on the /reauth page, they see an Authenticate button if biometric authentication is possible. Authentication with a fingerprint (UVPA) starts when they tap Authenticate, successfully authenticate, and then land on the /home page. If biometric authentication is not available or an authentication with biometric fails, the UI falls back to use the existing password form.

GOAL: Authenticate the user with a fingerprint
1. Create `authetnicate()` function
2. Obtain the challenge and other options from server
	> Before authentication, examine if the user has a stored credential ID and set it as a query parameter if they do.
		- When you provide a credential ID along with other options, the server can provide relevant allowCredentials and this makes user verification reliable.
	> Before you ask the user to authenticate, ask the server to send back a challenge and other parameters then call _fetch() with opts as an argument to send a POST request to the server.
	> Check if allowedCredentials property array contains object
		- if empty array, return a Promise with resolve value of null
3. Locally verify the user and get a credential
	> Because these options are delivered encoded in order to go through HTTP protocol, convert some parameters back to binary, specifically challenge and instances of id included in the allowCredentials array:
	> Call the navigator.credentials.get() method to verify the user's identity with a UVPA.
		- Once the user verifies their identity, you should receive a credential object that you can send to the server and authenticate the user.
		- this should return an object similar to PublicKeyCredential of WebAuthn specification
4. Verify the credential: `/auth/signinResponse`
	> Using the PublicKeyCredential received from navigator.credential.get(), 
		- encode the binary parameters of the credential so that it can be delivered to the server as a string:
		- Send the object to the server and, if it returns HTTP code 200, consider the user as successfully signed in:




// FINAL CODE
// public/client.js

// TODO (3): Authenticate the user with a fingerprint
// 1. Create `authetnicate()` function
// 2. Obtain the challenge and other options from server
// 3. Locally verify the user and get a credential
// 4. Verify the credential: `/auth/signinResponse`

export const authenticate = async () => {
  // create placeholder object for signinRequest options
  const opts = {};

  // if credId is present, we will add it as query parameter "credId" value
  let url = "/auth/signinRequest";
  const credId = localStorage.getItem(`credId`);
  if (credId) {
    url += `?credId=${encodeURIComponent(credId)}`;
  }
  
  // fetch the PublicKeyCredentialRequestOptions object from the Server
  const options = await _fetch(url, opts);

  // if no allowCredentials exist property in response (which contains array of credentials object with id property
  // we will return a Promise whose resolve value is null
  // this value will be used to determine if user will be prompted for UVPA authentication (if value exist) or not (if value is null)
  if (options.allowCredentials.length === 0) {
    console.info("No registered credentials found.");
    return Promise.resolve(null);
  }

  // decode challenge using base64
  options.challenge = base64url.decode(options.challenge);

  // decode all id property of credentials object inside allowCredentials
  for (let cred of options.allowCredentials) {
    cred.id = base64url.decode(cred.id);
  }
  
  // fetch the Credential instance using the options we have received from Server
  const cred = await navigator.credentials.get({
    publicKey: options
  });

  // create a placeholder for credential that we will submit to Server
  const credential = {};
  credential.id = cred.id;
  credential.type = cred.type;
  // encode the rawId to base64
  credential.rawId = base64url.encode(cred.rawId);

  // if the response property is present, base64 encode the properties of it as well
  // then set the results as property of placeholder with same name
  if (cred.response) {
    const clientDataJSON =
      base64url.encode(cred.response.clientDataJSON);
    const authenticatorData =
      base64url.encode(cred.response.authenticatorData);
    const signature =
      base64url.encode(cred.response.signature);
    const userHandle =
      base64url.encode(cred.response.userHandle);
    credential.response = {
      clientDataJSON,
      authenticatorData,
      signature,
      userHandle,
    };
  }

  // send the credentials to Server for authentication
  return await _fetch(`/auth/signinResponse`, credential);
};





















VI. Enable reauthentication experience
GOAL: Enable reauth experience
STEPS:
1. Build UI
	> for reauthentication UI, we will need to consider the following
		- The UVPA is not available.
		- The user has not registered any credentials on their device yet.
		- The storage is cleared and the device no longer remembers the credential ID.
		- The user is unable to verify their identity for some reason, such as when their finger is wet or they're wearing a mask.
	> for this reason, it is IMPORTANT to still provide other sign-in options as fallback like form-based password solution
2. Feature detection and UVPA availability
	> check if UVPA is available and if features needed like Credential Management API exist
	> based on these information, we will determine if we will show the re authentication UI or another sign-in option
3. Fallback to password form
	> if UVPA is not available and Credential Management API is not support in browser, we must be able to show other sign-in option
4. Invoke the biometric authentication
	> here, we will use the authenticate() function imported from client.js


// FINAL CODE

// inside <body> tag of reauth.html
    <mwc-top-app-bar-fixed>
      <span slot="title">WebAuthn codelab</span>
    </mwc-top-app-bar-fixed>
    <main class="content">
      <!--
        TODO(4): Enable reauth experience
        1. Build UI
      -->
      <div id="uvpa_available" class="hidden">
        <h2>Verify your identity</h2>
        <div>
          <mwc-button id="reauth" raised>Authenticate</mwc-button>
        </div>
        <div>
          <mwc-button id="cancel">Sign-in with password</mwc-button>
        </div>
      </div>
      <form id="form" method="POST" action="/auth/password" class="hidden">
        <!-- TODO(4) - 1. -->
        <h2>Enter a password</h2>
        <input type="hidden" name="username" value="{{username}}" />
        <div class="mdc-text-field mdc-text-field--filled">
          <span class="mdc-text-field__ripple"></span>
          <label class="mdc-floating-label" id="password-label">password</label>
          <input
            type="password"
            class="mdc-text-field__input"
            aria-labelledby="password-label"
            name="password"
          />
          <span class="mdc-line-ripple"></span>
        </div>
        <input
          type="submit"
          class="mdc-button mdc-button--raised"
          value="Sign-In"
        />
        <p class="instructions">password will be ignored in this demo.</p>
      </form>
    </main>
    <script src="https://unpkg.com/material-components-web@7.0.0/dist/material-components-web.min.js"></script>
    <script type="module">
      new mdc.textField.MDCTextField(document.querySelector(".mdc-text-field"));
      // Import authenticate from client.js
      import { _fetch, authenticate } from "/client.js"; // TODO(4) - 4
      
      // submit eventListener of form
      const form = document.querySelector("#form");
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        const form = new FormData(e.target);
        const cred = {};
        form.forEach((v, k) => (cred[k] = v));
        _fetch(e.target.action, cred)
          .then((user) => {
            location.href = "/home";
          })
          .catch((e) => alert(e));
      });

      // TODO(4): Enable reauth experience
      // 2. Feature detection and UVPA availability
      // 3. Fallback to password form
      // 4. Invoke the biometric authentication
      
      // check if feature is present and UVPA availability
      // based on these information, display 
      if (window.PublicKeyCredential) {
        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(
          (uvpaa) => {
            // if uvpaa present and theres a credential id present in client, display the content for reauthentication
            // else, display another authentication option present
            if (uvpaa && localStorage.getItem(`credId`)) {
              document
                .querySelector("#uvpa_available")
                .classList.remove("hidden");
            } else {
              form.classList.remove("hidden");
            }
          }
        );
      } else {
        // else, display another authentication option present
        form.classList.remove("hidden");
      }
      
      // set click eventHandler for cancel button
      // when clicked, remove the re authentication content, and display content for alternative authentication option
      const cancel = document.querySelector("#cancel");
      cancel.addEventListener("click", (e) => {
        form.classList.remove("hidden");
        document.querySelector("#uvpa_available").classList.add("hidden");
      });

      // setup reauth button click eventHandler
      // inside, use the authenticate() method imported from client.js
      const button = document.querySelector("#reauth");
      button.addEventListener("click", (e) => {
        authenticate()
          .then((user) => {
            if (user) {
              location.href = "/home";
            } else {
              throw "User not found.";
            }
          })
          .catch((e) => {
            console.error(e.message || e);
            alert("Authentication failed. Use password to sign-in.");
            form.classList.remove("hidden");
            document.querySelector("#uvpa_available").classList.add("hidden");
          });
      });
    </script>









VII. Final

You finished this codelab!

Learn more
Web Authentication: An API for accessing Public Key Credentials Level 1
Introduction to WebAuthn API
FIDO WebAuthn Workshop
WebAuthn Guide: DUOSEC
Your first Android FIDO2 API
Special thanks to Yuriy Ackermann from FIDO Alliance for your help.
