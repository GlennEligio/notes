Lombok


Problem
	> many boiler plate code when creating Class (specifically POJOs)

SOLUTION	
	> Project Lombok



Project Lombok
	> used to reduce boilerplate codes
	> before we can use it, we need to
		- add Dependency
		- add Plugins for Lombo

Boilerplate
	> term used to describe code that is repeated in many parts of an application with little alteration. 
	> One of the most frequently voiced criticisms of the Java language is the volume of this type of code that is found in most projects. 
	> This problem is frequently a result of design decisions in various libraries, but it's exacerbated by limitations in the language itself. 
	> Project Lombok aims to reduce the prevalence of some of the worst offenders by replacing them with a simple set of annotations.


Maven Dependency
	> note that you can add this when creating project using Spring Initialzr

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>0.9.2</version>
    </dependency>




Lombok Annotations


INNER MEMBER ANNOTATIONS

@Getter
	> used to generate a getter for a field
	> can define the Access Modifier by passing lombok.AccessLevel enum value to it
		- by default, access modifier of field is PUBLIC

public class MyCandlestick {

    @Getter(lombok.AccessLevel.PROTECTED)
    private String name;



@Setter
	> used to generate a setter for a field
	> can define the Access Modifier by passing lombok.AccessLevel enum value to it
		- by default, access modifier of field is PUBLIC

    @Setter(lombok.AccessLevel.PROTECTED)
    private double close;



@NonNull
	> adds a null check to any methods that set the field such as setters and constructors
	> if an attempt to set the field with a null value is performed, a NullPointerException is thrown with the name of the field mentioned in the exception


    @NonNull
    @Setter
    private String name;



@With
	> used to generate a method which makes a copy of the object, BUT with a modified value of the annotated field
	> NEEDS to be combined with an @AllArgsConstructor annotation to work

@AllArgsConstructor
public class MyCandlestick {

    @With
    private String name;

    private double close;

}




METHOD LEVEL ANNOTATIONS

@Synchronized
	> preferred over using Java's synchronized keyword because unlike the synchronized keyword which locks on "this", the annotation will synchronize the method on an inner variable
		- "this" refers to the Class instance (Object)
	> the lock object will be generated by the Lombok automatically if you do not explicitly define it

    @Synchronized
    public void testSync(){
        //....
    }


@SneakyThrows
	> an annotation that could be added to a method which throws a checked exception
	> allows you to omit adding the "throws..." clause to a method signature


    @SneakyThrows
    public void testSneaky(){
        BufferedReader bufferedReader =
                new BufferedReader(new InputStreamReader(System.in));
        bufferedReader.read();
    }



CLASS LEVEL ANNOTATIONS

@Getter
	> if added in Class, Lombok will create Getters to each field in the class

@Getter
public class MyCandlestick {


@Setter
	> if added in Class, Lombok will create Setters to each field in the Class

@Setter
public class MyCandlestick {


@NoArgsConstructir
	> adds zero arguments constructor to the class

		@Setter
		@NoArgsConstructor
		public class MyCandlestick {

	> can also define the access level of constructor by passing AccessLevel enum value to its "access" parameter

		@NoArgsConstructor(access = AccessLevel.PUBLIC)	

	> we can also create a static method which will encapsulate this @NoArgsConstructor method
		- we can define the name of the said method by defining the "staticName" parameter of @NoArgsConstructor
		
		@NoArgsConstructor(access = AccessLevel.PUBLIC, staticName = "of")


@AllArgsConstructor
	> add a constructor with an argument list of the same length and order as the inner fiekds that exist in the class
	> we can also define the "staticName" parameter, which will create a static method to encapsulate this constructor

EX:
@AllArgsConstructor
public class MyCandlestick {

    private String name;

    private double close;

    private int volume;


Usage
	MyCandlestick candlestick1 = new MyCandlestick("", 1.2, 2);




@RequiredArgsConstructor
	> will generate a constructor with only the require fields
	> Required fields are
		- non-initialized final fields
		- annotated with @NonNull
	> also have "access" and "staticName" parameters that can be defined


@RequiredArgsConstructor
public class MyCandlestick {

    private String name;

    private double close;

    private final int required1;
    
    @NonNull
    private String required2;

    private static int bla;


}



@Builder
	> provides with a Builder pattern interface for the annotated class

@Builder
public class MyCandlestick {

    private String name;

    private double close;

}


MyCandlestick candlestick1 = MyCandlestick.builder()
					.close(3.2)
					.name("hello")
					.build();



@ToString
	> when added in Class, will generate a toString method
		- by default, all fields are included in the output
	> to exclude a field, define the "exclude" parameter
		- this parameter takes an array of String
		- this String should match the name of field


@ToString(exclude = {"close"})
public class MyCandlestick {
    
    private String name;

    private double close;

}



@EqualsAndHashCode
	> generate an .equals() and .hashCode() method for the Class
	> we can also define the "exclude" to exclude specific fields into the output

@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class MyCandlestick {

    private String name;

    @EqualsAndHashCode.Include
    private double close;

}



@Data
	> all in one package
	> equivalent to adding the annotations
		- @Getter, @Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode

@Data
public class MyCandlestick {




	